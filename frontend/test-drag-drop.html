<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拖拽漏斗构建器测试</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        [v-cloak] { display: none; }
        
        /* 基本拖拽样式 */
        .drag-item {
            cursor: grab;
            transition: all 0.2s ease;
        }
        
        .drag-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .drag-item:active {
            cursor: grabbing;
        }
        
        .drag-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        
        .drop-zone {
            transition: all 0.3s ease;
        }
        
        .drop-zone.drag-over {
            background-color: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
        }
        
        /* SVG 样式 */
        .funnel-node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .funnel-node:hover {
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.3));
        }
        
        .funnel-node.selected {
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.8));
        }
        
        .funnel-node.dragging {
            opacity: 0.8;
            filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.3));
        }
        
        .connection-line {
            stroke-width: 2;
            fill: none;
            transition: stroke 0.2s ease, stroke-width 0.2s ease;
        }
        
        .connection-preview {
            stroke-dasharray: 8,4;
            animation: dash 2s linear infinite;
        }
        
        @keyframes dash {
            to { stroke-dashoffset: -24; }
        }
        
        .connection-point {
            cursor: crosshair;
            transition: all 0.2s ease;
        }
        
        .connection-point:hover {
            r: 8;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" v-cloak>
        <div class="h-screen flex">
            <!-- 节点面板 -->
            <div class="w-80 bg-white border-r border-gray-200 p-4">
                <h2 class="text-lg font-semibold mb-4 text-gray-800">节点类型</h2>
                
                <div class="space-y-3">
                    <div 
                        v-for="nodeType in nodeTypes" 
                        :key="nodeType.type"
                        class="drag-item p-3 border-2 border-dashed border-gray-200 rounded-lg hover:border-gray-300"
                        :class="{ 'dragging': isDragging && draggedNodeType?.type === nodeType.type }"
                        draggable="true"
                        @dragstart="handleDragStart($event, nodeType)"
                        @dragend="handleDragEnd"
                    >
                        <div class="flex items-center space-x-3">
                            <div 
                                class="w-10 h-10 rounded-lg flex items-center justify-center text-white shadow-sm"
                                :class="nodeType.color"
                            >
                                <span class="text-sm font-bold">{{ nodeType.icon }}</span>
                            </div>
                            <div class="flex-1">
                                <h3 class="font-medium text-gray-900">{{ nodeType.label }}</h3>
                                <p class="text-sm text-gray-500">{{ nodeType.description }}</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 pt-6 border-t border-gray-200">
                    <h3 class="font-medium text-gray-800 mb-2">使用说明</h3>
                    <div class="text-sm text-gray-600 space-y-1">
                        <p>• 拖拽节点到右侧画布创建</p>
                        <p>• 拖拽节点可移动位置</p>
                        <p>• 点击输出点开始连接</p>
                        <p>• 鼠标滚轮缩放画布</p>
                        <p>• 双击节点编辑属性</p>
                    </div>
                </div>
                
                <div class="mt-4 p-3 bg-blue-50 rounded-lg">
                    <div class="text-sm">
                        <div><strong>节点:</strong> {{ nodes.length }}</div>
                        <div><strong>连接:</strong> {{ edges.length }}</div>
                        <div v-if="selectedNode"><strong>已选择:</strong> {{ selectedNode.data.label }}</div>
                    </div>
                </div>
            </div>
            
            <!-- 画布区域 -->
            <div class="flex-1 relative">
                <svg
                    ref="canvas"
                    class="w-full h-full drop-zone"
                    :class="{ 'drag-over': isDragOverCanvas }"
                    @dragover.prevent="handleCanvasDragOver"
                    @drop.prevent="handleCanvasDrop"
                    @dragenter.prevent="handleCanvasDragEnter"
                    @dragleave="handleCanvasDragLeave"
                    @click="handleCanvasClick"
                    @mousemove="handleMouseMove"
                    @mouseup="handleMouseUp"
                >
                    <defs>
                        <!-- 箭头标记 -->
                        <marker
                            id="arrow"
                            viewBox="0 0 10 10"
                            refX="9"
                            refY="3"
                            markerWidth="6"
                            markerHeight="6"
                            orient="auto"
                            markerUnits="strokeWidth"
                        >
                            <path d="M0,0 L0,6 L9,3 z" fill="#666" />
                        </marker>
                        
                        <!-- 网格图案 -->
                        <pattern
                            id="grid"
                            width="20"
                            height="20"
                            patternUnits="userSpaceOnUse"
                        >
                            <path
                                d="M 20 0 L 0 0 0 20"
                                fill="none"
                                stroke="#e5e7eb"
                                stroke-width="0.5"
                                opacity="0.5"
                            />
                        </pattern>
                    </defs>

                    <!-- 网格背景 -->
                    <rect v-if="showGrid" width="100%" height="100%" fill="url(#grid)" />
                    
                    <!-- 主容器组 -->
                    <g ref="container">
                        <!-- 连接线 -->
                        <g class="edges">
                            <path
                                v-for="edge in edges"
                                :key="edge.id"
                                :d="getConnectionPath(edge)"
                                class="connection-line"
                                stroke="#6b7280"
                                marker-end="url(#arrow)"
                                @click="selectEdge(edge)"
                            />
                        </g>
                        
                        <!-- 临时连接线 -->
                        <path
                            v-if="isConnecting && connectionStart"
                            :d="getPreviewConnectionPath()"
                            class="connection-line connection-preview"
                            stroke="#3b82f6"
                            stroke-width="3"
                            opacity="0.7"
                        />
                        
                        <!-- 节点 -->
                        <g class="nodes">
                            <g
                                v-for="node in nodes"
                                :key="node.id"
                                class="funnel-node"
                                :class="{ 
                                    'selected': selectedNode?.id === node.id,
                                    'dragging': isDraggingNode && draggedNode?.id === node.id
                                }"
                                :transform="`translate(${node.position.x}, ${node.position.y})`"
                                @click="selectNode(node)"
                                @dblclick="editNode(node)"
                                @mousedown="startNodeDrag($event, node)"
                            >
                                <!-- 节点背景 -->
                                <rect
                                    width="120"
                                    height="60"
                                    rx="8"
                                    :fill="getNodeColor(node.type)"
                                    stroke="white"
                                    :stroke-width="selectedNode?.id === node.id ? 3 : 2"
                                />
                                
                                <!-- 节点图标 -->
                                <text
                                    x="20"
                                    y="35"
                                    text-anchor="middle"
                                    dominant-baseline="middle"
                                    class="text-lg font-bold fill-white"
                                >
                                    {{ getNodeIcon(node.type) }}
                                </text>
                                
                                <!-- 节点标签 -->
                                <text
                                    x="60"
                                    y="30"
                                    text-anchor="middle"
                                    dominant-baseline="middle"
                                    class="text-sm font-medium fill-white"
                                >
                                    {{ node.data.label }}
                                </text>
                                
                                <!-- 连接点 -->
                                <g v-if="!readonly">
                                    <!-- 输入点 -->
                                    <circle
                                        v-if="node.type !== 'start'"
                                        cx="0"
                                        cy="30"
                                        r="6"
                                        fill="#3b82f6"
                                        stroke="white"
                                        stroke-width="2"
                                        class="connection-point"
                                        @mouseup="handleConnectionEnd(node)"
                                    />
                                    
                                    <!-- 输出点 -->
                                    <circle
                                        v-if="node.type !== 'end'"
                                        cx="120"
                                        cy="30"
                                        r="6"
                                        fill="#10b981"
                                        stroke="white"
                                        stroke-width="2"
                                        class="connection-point"
                                        @mousedown="handleConnectionStart($event, node)"
                                    />
                                </g>
                            </g>
                        </g>
                    </g>
                </svg>
                
                <!-- 画布控制 -->
                <div class="absolute top-4 left-4 flex gap-2">
                    <button
                        @click="resetView"
                        class="px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 text-sm"
                    >
                        重置视图
                    </button>
                    <button
                        @click="fitToView"
                        class="px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 text-sm"
                    >
                        适应画布
                    </button>
                    <button
                        @click="toggleGrid"
                        class="px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 text-sm"
                        :class="showGrid ? 'bg-blue-50 border-blue-300 text-blue-700' : ''"
                    >
                        网格
                    </button>
                </div>
                
                <!-- 缩放显示 -->
                <div class="absolute bottom-4 right-4 bg-white border border-gray-300 rounded-lg shadow-sm p-3">
                    <div class="text-xs text-gray-600">
                        缩放: {{ Math.round(currentZoom * 100) }}%
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, nextTick } = Vue

        createApp({
            setup() {
                // 状态
                const nodes = ref([])
                const edges = ref([])
                const selectedNode = ref(null)
                const selectedEdge = ref(null)
                const showGrid = ref(true)
                const currentZoom = ref(1)
                const isDragging = ref(false)
                const draggedNodeType = ref(null)
                const isDragOverCanvas = ref(false)
                const isDraggingNode = ref(false)
                const draggedNode = ref(null)
                const isConnecting = ref(false)
                const connectionStart = ref(null)
                const mousePosition = ref({ x: 0, y: 0 })
                const canvas = ref(null)
                const container = ref(null)
                const readonly = ref(false)
                
                let nodeIdCounter = 0
                let edgeIdCounter = 0
                let zoom = null
                let dragOffset = { x: 0, y: 0 }

                // 节点类型配置
                const nodeTypes = [
                    {
                        type: 'start',
                        label: '起始节点',
                        description: '流程开始点',
                        color: 'bg-green-500',
                        icon: '▶'
                    },
                    {
                        type: 'action',
                        label: '行动节点',
                        description: '执行操作',
                        color: 'bg-purple-500',
                        icon: '⚡'
                    },
                    {
                        type: 'condition',
                        label: '条件节点',
                        description: '条件判断',
                        color: 'bg-blue-500',
                        icon: '?'
                    },
                    {
                        type: 'conversion',
                        label: '转化节点',
                        description: '转化目标',
                        color: 'bg-emerald-500',
                        icon: '✓'
                    },
                    {
                        type: 'end',
                        label: '结束节点',
                        description: '流程终点',
                        color: 'bg-red-500',
                        icon: '■'
                    }
                ]

                // 获取节点颜色
                const getNodeColor = (type) => {
                    const nodeType = nodeTypes.find(nt => nt.type === type)
                    const colorMap = {
                        'bg-green-500': '#10b981',
                        'bg-purple-500': '#8b5cf6',
                        'bg-blue-500': '#3b82f6',
                        'bg-emerald-500': '#10b981',
                        'bg-red-500': '#ef4444'
                    }
                    return colorMap[nodeType?.color] || '#6b7280'
                }

                // 获取节点图标
                const getNodeIcon = (type) => {
                    return nodeTypes.find(nt => nt.type === type)?.icon || '●'
                }

                // 拖拽处理
                const handleDragStart = (event, nodeType) => {
                    isDragging.value = true
                    draggedNodeType.value = nodeType
                    
                    const dragData = JSON.stringify({
                        type: 'palette-node',
                        nodeType: nodeType
                    })
                    
                    event.dataTransfer.setData('application/json', dragData)
                    event.dataTransfer.effectAllowed = 'copy'
                }

                const handleDragEnd = () => {
                    isDragging.value = false
                    draggedNodeType.value = null
                }

                const handleCanvasDragOver = (event) => {
                    event.dataTransfer.dropEffect = 'copy'
                    isDragOverCanvas.value = true
                }

                const handleCanvasDragEnter = (event) => {
                    isDragOverCanvas.value = true
                }

                const handleCanvasDragLeave = (event) => {
                    if (!canvas.value.contains(event.relatedTarget)) {
                        isDragOverCanvas.value = false
                    }
                }

                const handleCanvasDrop = (event) => {
                    isDragOverCanvas.value = false
                    
                    try {
                        const data = JSON.parse(event.dataTransfer.getData('application/json'))
                        if (data.type === 'palette-node' && data.nodeType) {
                            const rect = canvas.value.getBoundingClientRect()
                            const transform = d3.zoomTransform(canvas.value)
                            
                            const position = {
                                x: Math.max(0, (event.clientX - rect.left - transform.x) / transform.k - 60),
                                y: Math.max(0, (event.clientY - rect.top - transform.y) / transform.k - 30)
                            }
                            
                            addNode(data.nodeType, position)
                        }
                    } catch (error) {
                        console.error('Failed to parse drop data:', error)
                    }
                }

                // 添加节点
                const addNode = (nodeType, position) => {
                    const node = {
                        id: `node_${++nodeIdCounter}`,
                        type: nodeType.type,
                        position: position,
                        data: {
                            label: `${nodeType.label} ${nodeIdCounter}`,
                            description: nodeType.description,
                            config: {}
                        }
                    }
                    
                    nodes.value.push(node)
                }

                // 节点选择
                const selectNode = (node) => {
                    selectedNode.value = node
                    selectedEdge.value = null
                }

                const selectEdge = (edge) => {
                    selectedEdge.value = edge
                    selectedNode.value = null
                }

                // 节点拖拽
                const startNodeDrag = (event, node) => {
                    if (readonly.value) return
                    
                    event.stopPropagation()
                    event.preventDefault()
                    isDraggingNode.value = true
                    draggedNode.value = node
                    
                    const rect = canvas.value.getBoundingClientRect()
                    const transform = d3.zoomTransform(canvas.value)
                    
                    // Calculate precise mouse position in canvas coordinates
                    const canvasMouseX = (event.clientX - rect.left - transform.x) / transform.k
                    const canvasMouseY = (event.clientY - rect.top - transform.y) / transform.k
                    
                    // Store offset from mouse to node position
                    dragOffset = {
                        x: canvasMouseX - node.position.x,
                        y: canvasMouseY - node.position.y
                    }
                    
                    // Add dragging class for visual feedback
                    event.currentTarget.classList.add('dragging')
                    document.body.style.cursor = 'grabbing'
                    document.body.style.userSelect = 'none'
                    
                    console.log('Drag started - Mouse canvas pos:', { x: canvasMouseX, y: canvasMouseY })
                    console.log('Drag started - Node pos:', node.position)
                    console.log('Drag started - Offset:', dragOffset)
                    
                    document.addEventListener('mousemove', onNodeDrag, { passive: false })
                    document.addEventListener('mouseup', onNodeDragEnd)
                }

                const onNodeDrag = (event) => {
                    if (!isDraggingNode.value || !draggedNode.value) return
                    
                    const rect = canvas.value.getBoundingClientRect()
                    const transform = d3.zoomTransform(canvas.value)
                    
                    // Calculate precise mouse position in canvas coordinates
                    const canvasMouseX = (event.clientX - rect.left - transform.x) / transform.k
                    const canvasMouseY = (event.clientY - rect.top - transform.y) / transform.k
                    
                    // Calculate new position by subtracting the drag offset
                    const newPosition = {
                        x: Math.max(0, canvasMouseX - dragOffset.x),
                        y: Math.max(0, canvasMouseY - dragOffset.y)
                    }
                    
                    draggedNode.value.position = newPosition
                }

                const onNodeDragEnd = () => {
                    console.log('Drag ended')
                    
                    isDraggingNode.value = false
                    draggedNode.value = null
                    
                    // Remove dragging class and reset cursor
                    const draggingElements = document.querySelectorAll('.dragging')
                    draggingElements.forEach(el => el.classList.remove('dragging'))
                    
                    document.body.style.cursor = ''
                    document.body.style.userSelect = ''
                    
                    document.removeEventListener('mousemove', onNodeDrag)
                    document.removeEventListener('mouseup', onNodeDragEnd)
                }

                // 连接处理
                const handleConnectionStart = (event, node) => {
                    event.stopPropagation()
                    isConnecting.value = true
                    connectionStart.value = {
                        nodeId: node.id,
                        position: {
                            x: node.position.x + 120,
                            y: node.position.y + 30
                        }
                    }
                }

                const handleConnectionEnd = (targetNode) => {
                    if (!isConnecting.value || !connectionStart.value) return
                    
                    if (connectionStart.value.nodeId !== targetNode.id) {
                        // 添加连接
                        const edge = {
                            id: `edge_${++edgeIdCounter}`,
                            source: connectionStart.value.nodeId,
                            target: targetNode.id,
                            type: 'default',
                            data: { config: {} }
                        }
                        
                        edges.value.push(edge)
                    }
                    
                    isConnecting.value = false
                    connectionStart.value = null
                }

                const handleMouseMove = (event) => {
                    if (!canvas.value) return
                    
                    const rect = canvas.value.getBoundingClientRect()
                    const transform = d3.zoomTransform(canvas.value)
                    
                    mousePosition.value = {
                        x: (event.clientX - rect.left - transform.x) / transform.k,
                        y: (event.clientY - rect.top - transform.y) / transform.k
                    }
                }

                const handleMouseUp = () => {
                    if (isConnecting.value) {
                        isConnecting.value = false
                        connectionStart.value = null
                    }
                }

                // 连接路径生成
                const getConnectionPath = (edge) => {
                    const sourceNode = nodes.value.find(n => n.id === edge.source)
                    const targetNode = nodes.value.find(n => n.id === edge.target)
                    
                    if (!sourceNode || !targetNode) return ''
                    
                    const sx = sourceNode.position.x + 120
                    const sy = sourceNode.position.y + 30
                    const tx = targetNode.position.x
                    const ty = targetNode.position.y + 30
                    
                    const dx = tx - sx
                    const controlPointOffset = Math.abs(dx) * 0.5
                    
                    const cp1x = sx + controlPointOffset
                    const cp1y = sy
                    const cp2x = tx - controlPointOffset
                    const cp2y = ty
                    
                    return `M ${sx},${sy} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${tx},${ty}`
                }

                const getPreviewConnectionPath = () => {
                    if (!connectionStart.value) return ''
                    
                    const start = connectionStart.value.position
                    const end = mousePosition.value
                    
                    const dx = end.x - start.x
                    const controlPointOffset = Math.abs(dx) * 0.5
                    
                    const cp1x = start.x + controlPointOffset
                    const cp1y = start.y
                    const cp2x = end.x - controlPointOffset
                    const cp2y = end.y
                    
                    return `M ${start.x},${start.y} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${end.x},${end.y}`
                }

                // 画布控制
                const handleCanvasClick = (event) => {
                    if (event.target === canvas.value) {
                        selectedNode.value = null
                        selectedEdge.value = null
                    }
                }

                const toggleGrid = () => {
                    showGrid.value = !showGrid.value
                }

                const resetView = () => {
                    if (zoom) {
                        d3.select(canvas.value)
                            .transition()
                            .duration(500)
                            .call(zoom.transform, d3.zoomIdentity)
                    }
                }

                const fitToView = () => {
                    if (!zoom || nodes.value.length === 0) return
                    
                    const padding = 50
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity
                    
                    nodes.value.forEach(node => {
                        minX = Math.min(minX, node.position.x - padding)
                        maxX = Math.max(maxX, node.position.x + 120 + padding)
                        minY = Math.min(minY, node.position.y - padding)
                        maxY = Math.max(maxY, node.position.y + 60 + padding)
                    })
                    
                    const width = maxX - minX
                    const height = maxY - minY
                    const rect = canvas.value.getBoundingClientRect()
                    
                    const scale = Math.min(rect.width / width, rect.height / height, 1)
                    const translateX = (rect.width - width * scale) / 2 - minX * scale
                    const translateY = (rect.height - height * scale) / 2 - minY * scale
                    
                    d3.select(canvas.value)
                        .transition()
                        .duration(500)
                        .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale))
                }

                const editNode = (node) => {
                    const newLabel = prompt('请输入新的节点标签:', node.data.label)
                    if (newLabel) {
                        node.data.label = newLabel
                    }
                }

                // 初始化 D3
                onMounted(async () => {
                    await nextTick()
                    
                    if (canvas.value && container.value) {
                        zoom = d3.zoom()
                            .scaleExtent([0.1, 3])
                            .on('zoom', (event) => {
                                const { transform } = event
                                currentZoom.value = transform.k
                                d3.select(container.value).attr('transform', transform)
                            })

                        d3.select(canvas.value).call(zoom)
                    }
                })

                return {
                    nodes,
                    edges,
                    selectedNode,
                    selectedEdge,
                    showGrid,
                    currentZoom,
                    isDragging,
                    draggedNodeType,
                    isDragOverCanvas,
                    isDraggingNode,
                    isConnecting,
                    connectionStart,
                    readonly,
                    canvas,
                    container,
                    nodeTypes,
                    getNodeColor,
                    getNodeIcon,
                    handleDragStart,
                    handleDragEnd,
                    handleCanvasDragOver,
                    handleCanvasDragEnter,
                    handleCanvasDragLeave,
                    handleCanvasDrop,
                    selectNode,
                    selectEdge,
                    startNodeDrag,
                    handleConnectionStart,
                    handleConnectionEnd,
                    handleMouseMove,
                    handleMouseUp,
                    getConnectionPath,
                    getPreviewConnectionPath,
                    handleCanvasClick,
                    toggleGrid,
                    resetView,
                    fitToView,
                    editNode,
                    createDemoFunnel
                }
            }
        }).mount('#app')
    </script>
</body>
</html>