<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ğŸ“± ç§»åŠ¨ç«¯è§¦æ§æµ‹è¯• - Pathfinder</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        [v-cloak] { display: none; }
        
        /* ç§»åŠ¨ç«¯ä¸“ç”¨æ ·å¼ */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            margin: 0;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            overscroll-behavior: none;
            touch-action: pan-x pan-y;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* è§¦æ§èŠ‚ç‚¹æ ·å¼ */
        .touch-node {
            cursor: grab;
            touch-action: none;
            will-change: transform;
            transition: transform 0.15s ease-out;
        }
        
        .touch-node:active,
        .touch-node.dragging {
            cursor: grabbing;
            transform: scale(1.1);
            filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.3));
            z-index: 1000;
        }
        
        .touch-node.touch-feedback {
            background: radial-gradient(circle at center, rgba(59, 130, 246, 0.2) 0%, transparent 70%);
        }
        
        /* æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        .gesture-indicator {
            position: absolute;
            pointer-events: none;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.1);
            transform: translate(-50%, -50%);
            transition: all 0.2s ease;
        }
        
        /* è§¦æ§è½¨è¿¹ */
        .touch-trail {
            position: absolute;
            pointer-events: none;
            width: 4px;
            height: 4px;
            background: #f59e0b;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.7;
        }
        
        /* å‹åŠ›æŒ‡ç¤ºå™¨ */
        .pressure-indicator {
            position: absolute;
            pointer-events: none;
            border: 2px solid #ef4444;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* å“åº”å¼æ–­ç‚¹ */
        @media (max-width: 767px) {
            .phone-only { display: block !important; }
            .tablet-only, .desktop-only { display: none !important; }
        }
        
        @media (min-width: 768px) and (max-width: 1023px) {
            .tablet-only { display: block !important; }
            .phone-only, .desktop-only { display: none !important; }
        }
        
        @media (min-width: 1024px) {
            .desktop-only { display: block !important; }
            .phone-only, .tablet-only { display: none !important; }
        }
        
        /* æ€§èƒ½æŒ‡ç¤ºå™¨ */
        .performance-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            z-index: 9999;
        }
        
        /* è§¦æ§è°ƒè¯•é¢æ¿ */
        .debug-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        
        .debug-panel.visible {
            transform: translateY(0);
        }
        
        /* è®¾å¤‡æ–¹å‘æç¤º */
        .orientation-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            z-index: 10000;
            display: none;
        }
        
        @media (orientation: landscape) and (max-width: 767px) {
            .orientation-hint.show-landscape { display: block; }
        }
        
        /* åŠ¨ç”»å’Œè¿‡æ¸¡ */
        @keyframes touchRipple {
            0% { transform: scale(0.8) translate(-50%, -50%); opacity: 1; }
            100% { transform: scale(2) translate(-50%, -50%); opacity: 0; }
        }
        
        .touch-ripple {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(59, 130, 246, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: touchRipple 0.6s ease-out;
        }
        
        /* ä½æ€§èƒ½æ¨¡å¼ */
        .low-performance-mode * {
            transition: none !important;
            animation: none !important;
            filter: none !important;
        }
    </style>
</head>
<body>
    <div id="app" v-cloak>
        <!-- æ€§èƒ½æŒ‡ç¤ºå™¨ -->
        <div class="performance-indicator">
            <div>FPS: {{ performanceMetrics.fps }}</div>
            <div>å†…å­˜: {{ performanceMetrics.memoryUsage.toFixed(1) }}%</div>
            <div>ç”µæ± : {{ deviceInfo.batteryLevel ? (deviceInfo.batteryLevel * 100).toFixed(0) + '%' : 'N/A' }}</div>
            <div>å»¶è¿Ÿ: {{ performanceMetrics.latency.toFixed(0) }}ms</div>
        </div>
        
        <!-- è®¾å¤‡æ–¹å‘æç¤º -->
        <div class="orientation-hint show-landscape">
            <div class="text-lg font-bold mb-2">ğŸ“± è¯·æ—‹è½¬è®¾å¤‡</div>
            <div class="text-sm">ä¸ºäº†æ›´å¥½çš„ä½“éªŒï¼Œè¯·ä½¿ç”¨ç«–å±æ¨¡å¼</div>
        </div>
        
        <!-- ä¸»å¤´éƒ¨ -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-4 shadow-lg">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-xl font-bold">ğŸ“± ç§»åŠ¨ç«¯è§¦æ§æµ‹è¯•</h1>
                    <p class="text-sm opacity-90">{{ deviceInfo.deviceType.toUpperCase() }} - {{ deviceInfo.orientation.toUpperCase() }}</p>
                </div>
                <div class="text-right">
                    <div class="text-sm">{{ currentTime }}</div>
                    <div class="text-xs opacity-75">{{ touchStats.activeTouches }} ä¸ªè§¦ç‚¹</div>
                </div>
            </div>
        </div>

        <!-- å¿«é€Ÿæ§åˆ¶æ  -->
        <div class="bg-white border-b border-gray-200 p-2">
            <div class="flex items-center justify-between">
                <div class="flex space-x-2">
                    <button @click="addTestNode" class="px-3 py-2 bg-blue-500 text-white rounded-lg text-sm font-medium">
                        â• æ·»åŠ èŠ‚ç‚¹
                    </button>
                    <button @click="clearNodes" class="px-3 py-2 bg-red-500 text-white rounded-lg text-sm font-medium">
                        ğŸ—‘ï¸ æ¸…ç©º
                    </button>
                    <button @click="runTouchTest" class="px-3 py-2 bg-green-500 text-white rounded-lg text-sm font-medium">
                        ğŸ§ª è‡ªåŠ¨æµ‹è¯•
                    </button>
                </div>
                <div class="flex items-center space-x-2">
                    <button @click="showDebugPanel = !showDebugPanel" class="px-2 py-1 bg-gray-600 text-white rounded text-xs">
                        {{ showDebugPanel ? 'éšè—' : 'è°ƒè¯•' }}
                    </button>
                    <div class="text-xs text-gray-600">
                        èŠ‚ç‚¹: {{ nodes.length }}
                    </div>
                </div>
            </div>
        </div>

        <!-- æµ‹è¯•é…ç½® -->
        <div class="bg-gray-50 p-3 border-b">
            <div class="grid grid-cols-2 gap-3 text-sm">
                <label class="flex items-center justify-between">
                    <span>æ˜¾ç¤ºè½¨è¿¹</span>
                    <input v-model="testConfig.showTrails" type="checkbox" class="rounded">
                </label>
                <label class="flex items-center justify-between">
                    <span>å‹åŠ›æ£€æµ‹</span>
                    <input v-model="testConfig.enablePressure" type="checkbox" class="rounded">
                </label>
                <label class="flex items-center justify-between">
                    <span>å¤šç‚¹è§¦æ§</span>
                    <input v-model="testConfig.enableMultiTouch" type="checkbox" class="rounded">
                </label>
                <label class="flex items-center justify-between">
                    <span>æ€§èƒ½ä¼˜åŒ–</span>
                    <input v-model="testConfig.enablePerformanceMode" type="checkbox" class="rounded">
                </label>
            </div>
        </div>

        <!-- æµ‹è¯•ç”»å¸ƒ -->
        <div class="flex-1 relative overflow-hidden" :class="{ 'low-performance-mode': isLowPerformanceMode }">
            <!-- SVG ç”»å¸ƒ -->
            <svg 
                ref="canvas" 
                class="w-full h-full bg-gradient-to-br from-blue-50 to-purple-50"
                @touchstart="handleTouchStart"
                @touchmove="handleTouchMove"
                @touchend="handleTouchEnd"
                @touchcancel="handleTouchCancel"
                @click="handleCanvasClick"
                :viewBox="`0 0 ${canvasSize.width} ${canvasSize.height}`"
            >
                <!-- ç½‘æ ¼èƒŒæ™¯ -->
                <defs>
                    <pattern id="touchGrid" width="40" height="40" patternUnits="userSpaceOnUse">
                        <circle cx="20" cy="20" r="1" fill="rgba(0,0,0,0.1)"/>
                    </pattern>
                </defs>
                <rect v-if="testConfig.showGrid" width="100%" height="100%" fill="url(#touchGrid)"/>
                
                <!-- æµ‹è¯•èŠ‚ç‚¹ -->
                <g class="test-nodes">
                    <g
                        v-for="node in nodes"
                        :key="node.id"
                        :class="[
                            'touch-node',
                            { 
                                'dragging': dragState.nodeId === node.id,
                                'touch-feedback': node.touchFeedback
                            }
                        ]"
                        :transform="`translate(${node.position.x}, ${node.position.y})`"
                        @touchstart.stop="startNodeDrag($event, node)"
                        @mousedown.stop="startNodeDrag($event, node)"
                    >
                        <!-- èŠ‚ç‚¹ä¸»ä½“ -->
                        <circle
                            r="30"
                            :fill="getNodeColor(node)"
                            stroke="white"
                            stroke-width="3"
                            class="drop-shadow-lg"
                        />
                        
                        <!-- èŠ‚ç‚¹å›¾æ ‡ -->
                        <text
                            text-anchor="middle"
                            dominant-baseline="middle"
                            class="text-lg font-bold fill-white pointer-events-none"
                        >
                            {{ node.emoji }}
                        </text>
                        
                        <!-- è§¦æ§ç²¾åº¦æŒ‡ç¤ºå™¨ -->
                        <circle
                            v-if="dragState.nodeId === node.id"
                            r="35"
                            fill="none"
                            :stroke="getPrecisionColor()"
                            stroke-width="2"
                            stroke-dasharray="5,5"
                            class="precision-indicator"
                        />
                        
                        <!-- èŠ‚ç‚¹æ ‡ç­¾ -->
                        <text
                            y="50"
                            text-anchor="middle"
                            class="text-xs font-medium fill-gray-700 pointer-events-none"
                        >
                            {{ node.label }}
                        </text>
                        
                        <!-- è§¦æ§ç›®æ ‡å¤§å°æŒ‡ç¤º -->
                        <circle
                            v-if="testConfig.showTouchTargets"
                            r="22"
                            fill="none"
                            stroke="rgba(59, 130, 246, 0.3)"
                            stroke-width="1"
                            stroke-dasharray="2,2"
                        />
                    </g>
                </g>
                
                <!-- è§¦æ§è½¨è¿¹ -->
                <g v-if="testConfig.showTrails" class="touch-trails">
                    <circle
                        v-for="(trail, index) in touchTrails"
                        :key="index"
                        :cx="trail.x"
                        :cy="trail.y"
                        r="2"
                        :fill="trail.color"
                        :opacity="trail.opacity"
                    />
                </g>
            </svg>
            
            <!-- æ‰‹åŠ¿æŒ‡ç¤ºå™¨ -->
            <div
                v-for="gesture in activeGestures"
                :key="gesture.id"
                class="gesture-indicator"
                :style="{
                    left: gesture.center.x + 'px',
                    top: gesture.center.y + 'px',
                    width: (gesture.size || 40) + 'px',
                    height: (gesture.size || 40) + 'px'
                }"
            ></div>
            
            <!-- å‹åŠ›æŒ‡ç¤ºå™¨ -->
            <div
                v-for="touch in activeTouches"
                :key="'pressure-' + touch.id"
                v-if="testConfig.enablePressure && touch.pressure > 0"
                class="pressure-indicator"
                :style="{
                    left: touch.position.x + 'px',
                    top: touch.position.y + 'px',
                    width: (touch.pressure * 50) + 'px',
                    height: (touch.pressure * 50) + 'px',
                    opacity: touch.pressure
                }"
            ></div>
            
            <!-- è§¦æ§æ¶Ÿæ¼ªæ•ˆæœ -->
            <div
                v-for="ripple in touchRipples"
                :key="ripple.id"
                class="touch-ripple"
                :style="{ left: ripple.x + 'px', top: ripple.y + 'px' }"
            ></div>
        </div>

        <!-- è°ƒè¯•é¢æ¿ -->
        <div :class="['debug-panel', { visible: showDebugPanel }]">
            <div class="mb-2 font-bold">ğŸ”§ è§¦æ§è°ƒè¯•ä¿¡æ¯</div>
            <div class="grid grid-cols-2 gap-4 text-xs">
                <div>
                    <div class="font-medium text-blue-300 mb-1">è®¾å¤‡ä¿¡æ¯</div>
                    <div>ç±»å‹: {{ deviceInfo.deviceType }}</div>
                    <div>å°ºå¯¸: {{ deviceInfo.screenSize.width }}Ã—{{ deviceInfo.screenSize.height }}</div>
                    <div>åƒç´ æ¯”: {{ deviceInfo.devicePixelRatio }}x</div>
                    <div>æœ€å¤§è§¦ç‚¹: {{ deviceInfo.maxTouchPoints }}</div>
                    <div>æ”¯æŒå‹åŠ›: {{ deviceInfo.supportsPressure ? 'æ˜¯' : 'å¦' }}</div>
                </div>
                <div>
                    <div class="font-medium text-green-300 mb-1">è§¦æ§ç»Ÿè®¡</div>
                    <div>æ´»è·ƒè§¦ç‚¹: {{ touchStats.activeTouches }}</div>
                    <div>æ€»è§¦æ§æ•°: {{ touchStats.totalTouches }}</div>
                    <div>æ‹–æ‹½äº‹ä»¶: {{ touchStats.dragEvents }}</div>
                    <div>æ‰‹åŠ¿è¯†åˆ«: {{ touchStats.gestureEvents }}</div>
                    <div>å¹³å‡å»¶è¿Ÿ: {{ touchStats.averageLatency.toFixed(1) }}ms</div>
                </div>
            </div>
            <div class="mt-2">
                <div class="font-medium text-yellow-300 mb-1">æµ‹è¯•ç»“æœ</div>
                <div class="flex flex-wrap gap-2">
                    <span v-for="(result, test) in testResults" :key="test"
                          :class="[
                              'px-2 py-1 rounded text-xs',
                              result ? 'bg-green-600' : 'bg-red-600'
                          ]">
                        {{ test }}: {{ result ? 'âœ“' : 'âœ—' }}
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, nextTick } = Vue

        createApp({
            setup() {
                // çŠ¶æ€ç®¡ç†
                const nodes = ref([])
                const dragState = ref({ nodeId: null, startPos: null, offset: null })
                const showDebugPanel = ref(false)
                const canvas = ref(null)
                const currentTime = ref(new Date().toLocaleTimeString())
                
                // è§¦æ§ç›¸å…³çŠ¶æ€
                const activeTouches = ref([])
                const touchTrails = ref([])
                const activeGestures = ref([])
                const touchRipples = ref([])
                
                // é…ç½®
                const testConfig = ref({
                    showTrails: true,
                    enablePressure: true,
                    enableMultiTouch: true,
                    enablePerformanceMode: true,
                    showGrid: true,
                    showTouchTargets: false
                })
                
                // è®¾å¤‡ä¿¡æ¯
                const deviceInfo = ref({
                    deviceType: 'unknown',
                    orientation: 'unknown',
                    screenSize: { width: 0, height: 0 },
                    devicePixelRatio: 1,
                    maxTouchPoints: 0,
                    supportsPressure: false,
                    batteryLevel: null
                })
                
                // æ€§èƒ½æŒ‡æ ‡
                const performanceMetrics = ref({
                    fps: 60,
                    memoryUsage: 0,
                    latency: 0,
                    frameTime: 0
                })
                
                // è§¦æ§ç»Ÿè®¡
                const touchStats = ref({
                    activeTouches: 0,
                    totalTouches: 0,
                    dragEvents: 0,
                    gestureEvents: 0,
                    averageLatency: 0,
                    precisionErrors: []
                })
                
                // æµ‹è¯•ç»“æœ
                const testResults = ref({
                    'å•ç‚¹è§¦æ§': false,
                    'å¤šç‚¹è§¦æ§': false,
                    'æ‹–æ‹½ç²¾åº¦': false,
                    'å‹åŠ›æ£€æµ‹': false,
                    'æ‰‹åŠ¿è¯†åˆ«': false,
                    'æ€§èƒ½æµ‹è¯•': false
                })
                
                let nodeIdCounter = 0
                let performanceMonitor = null
                let trailCleanupInterval = null
                
                // è®¡ç®—å±æ€§
                const canvasSize = computed(() => ({
                    width: window.innerWidth,
                    height: window.innerHeight - 200 // å‡å»å¤´éƒ¨å’Œæ§åˆ¶æ 
                }))
                
                const isLowPerformanceMode = computed(() => 
                    testConfig.value.enablePerformanceMode && 
                    (performanceMetrics.value.fps < 30 || performanceMetrics.value.memoryUsage > 80)
                )
                
                // æ–¹æ³•
                const detectDeviceInfo = async () => {
                    // æ£€æµ‹è®¾å¤‡ç±»å‹
                    const width = window.innerWidth
                    let deviceType = 'desktop'
                    if (width < 768) deviceType = 'phone'
                    else if (width < 1024) deviceType = 'tablet'
                    
                    // æ£€æµ‹å±å¹•æ–¹å‘
                    const orientation = width > window.innerHeight ? 'landscape' : 'portrait'
                    
                    deviceInfo.value = {
                        deviceType,
                        orientation,
                        screenSize: { width: window.innerWidth, height: window.innerHeight },
                        devicePixelRatio: window.devicePixelRatio || 1,
                        maxTouchPoints: navigator.maxTouchPoints || 0,
                        supportsPressure: 'force' in Touch.prototype || 'webkitForce' in Touch.prototype,
                        batteryLevel: null
                    }
                    
                    // æ£€æµ‹ç”µæ± ä¿¡æ¯
                    try {
                        if ('getBattery' in navigator) {
                            const battery = await navigator.getBattery()
                            deviceInfo.value.batteryLevel = battery.level
                        }
                    } catch (e) {
                        // ç”µæ± APIå¯èƒ½ä¸å¯ç”¨
                    }
                }
                
                const addTestNode = () => {
                    const emojis = ['ğŸ¯', 'ğŸš€', 'â­', 'ğŸ’', 'ğŸ”¥', 'âš¡', 'ğŸ¨', 'ğŸª', 'ğŸ­', 'ğŸ¨']
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899']
                    
                    const node = {
                        id: `node_${++nodeIdCounter}`,
                        position: {
                            x: Math.random() * (canvasSize.value.width - 100) + 50,
                            y: Math.random() * (canvasSize.value.height - 100) + 50
                        },
                        emoji: emojis[Math.floor(Math.random() * emojis.length)],
                        color: colors[Math.floor(Math.random() * colors.length)],
                        label: `èŠ‚ç‚¹ ${nodeIdCounter}`,
                        touchFeedback: false
                    }
                    
                    nodes.value.push(node)
                }
                
                const clearNodes = () => {
                    nodes.value = []
                    nodeIdCounter = 0
                }
                
                const getNodeColor = (node) => {
                    if (dragState.value.nodeId === node.id) {
                        return '#1d4ed8' // æ‹–æ‹½æ—¶çš„é¢œè‰²
                    }
                    return node.color
                }
                
                const getPrecisionColor = () => {
                    const error = touchStats.value.precisionErrors[touchStats.value.precisionErrors.length - 1] || 0
                    if (error < 5) return '#10b981' // ç»¿è‰² - é«˜ç²¾åº¦
                    if (error < 10) return '#f59e0b' // é»„è‰² - ä¸­ç­‰ç²¾åº¦
                    return '#ef4444' // çº¢è‰² - ä½ç²¾åº¦
                }
                
                const handleTouchStart = (event) => {
                    event.preventDefault()
                    const startTime = performance.now()
                    
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i]
                        
                        const touchInfo = {
                            id: touch.identifier,
                            position: { x: touch.clientX, y: touch.clientY },
                            pressure: touch.force || touch.webkitForce || 0.5,
                            timestamp: startTime
                        }
                        
                        activeTouches.value.push(touchInfo)
                        
                        // åˆ›å»ºè§¦æ§æ¶Ÿæ¼ª
                        if (testConfig.value.showTrails) {
                            createTouchRipple(touch.clientX, touch.clientY)
                        }
                    }
                    
                    touchStats.value.activeTouches = activeTouches.value.length
                    touchStats.value.totalTouches++
                    
                    // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
                    performanceMetrics.value.latency = performance.now() - startTime
                }
                
                const handleTouchMove = (event) => {
                    event.preventDefault()
                    
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i]
                        const touchIndex = activeTouches.value.findIndex(t => t.id === touch.identifier)
                        
                        if (touchIndex !== -1) {
                            const oldPos = activeTouches.value[touchIndex].position
                            activeTouches.value[touchIndex].position = { x: touch.clientX, y: touch.clientY }
                            activeTouches.value[touchIndex].pressure = touch.force || touch.webkitForce || 0.5
                            
                            // æ·»åŠ è½¨è¿¹ç‚¹
                            if (testConfig.value.showTrails) {
                                addTrailPoint(touch.clientX, touch.clientY, touch.identifier)
                            }
                        }
                    }
                }
                
                const handleTouchEnd = (event) => {
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i]
                        const touchIndex = activeTouches.value.findIndex(t => t.id === touch.identifier)
                        
                        if (touchIndex !== -1) {
                            activeTouches.value.splice(touchIndex, 1)
                        }
                    }
                    
                    touchStats.value.activeTouches = activeTouches.value.length
                    
                    // ç»“æŸæ‹–æ‹½
                    if (dragState.value.nodeId) {
                        endNodeDrag()
                    }
                }
                
                const handleTouchCancel = (event) => {
                    activeTouches.value = []
                    touchStats.value.activeTouches = 0
                    
                    if (dragState.value.nodeId) {
                        endNodeDrag()
                    }
                }
                
                const startNodeDrag = (event, node) => {
                    event.preventDefault()
                    event.stopPropagation()
                    
                    const startTime = performance.now()
                    
                    // è·å–è§¦æ§æˆ–é¼ æ ‡ä½ç½®
                    let clientX, clientY
                    if (event.type === 'touchstart') {
                        const touch = event.touches[0]
                        clientX = touch.clientX
                        clientY = touch.clientY
                    } else {
                        clientX = event.clientX
                        clientY = event.clientY
                    }
                    
                    // è®¡ç®—åç§»
                    const rect = canvas.value.getBoundingClientRect()
                    const canvasX = clientX - rect.left
                    const canvasY = clientY - rect.top
                    
                    dragState.value = {
                        nodeId: node.id,
                        startPos: { x: canvasX, y: canvasY },
                        offset: {
                            x: canvasX - node.position.x,
                            y: canvasY - node.position.y
                        }
                    }
                    
                    // æ·»åŠ è§¦æ§åé¦ˆ
                    node.touchFeedback = true
                    
                    touchStats.value.dragEvents++
                    
                    // ç›‘å¬æ–‡æ¡£çº§åˆ«çš„ç§»åŠ¨å’Œç»“æŸäº‹ä»¶
                    document.addEventListener('touchmove', onDocumentTouchMove, { passive: false })
                    document.addEventListener('touchend', onDocumentTouchEnd)
                    document.addEventListener('mousemove', onDocumentMouseMove)
                    document.addEventListener('mouseup', onDocumentMouseEnd)
                    
                    console.log('å¼€å§‹æ‹–æ‹½èŠ‚ç‚¹:', node.id)
                }
                
                const onDocumentTouchMove = (event) => {
                    if (!dragState.value.nodeId) return
                    
                    event.preventDefault()
                    const touch = event.touches[0]
                    if (!touch) return
                    
                    updateNodePosition(touch.clientX, touch.clientY)
                }
                
                const onDocumentMouseMove = (event) => {
                    if (!dragState.value.nodeId) return
                    
                    event.preventDefault()
                    updateNodePosition(event.clientX, event.clientY)
                }
                
                const updateNodePosition = (clientX, clientY) => {
                    const rect = canvas.value.getBoundingClientRect()
                    const canvasX = clientX - rect.left
                    const canvasY = clientY - rect.top
                    
                    const newX = canvasX - dragState.value.offset.x
                    const newY = canvasY - dragState.value.offset.y
                    
                    // è¾¹ç•Œæ£€æµ‹
                    const boundedX = Math.max(30, Math.min(newX, canvasSize.value.width - 30))
                    const boundedY = Math.max(30, Math.min(newY, canvasSize.value.height - 30))
                    
                    // æ›´æ–°èŠ‚ç‚¹ä½ç½®
                    const node = nodes.value.find(n => n.id === dragState.value.nodeId)
                    if (node) {
                        node.position.x = boundedX
                        node.position.y = boundedY
                        
                        // è®¡ç®—ç²¾åº¦è¯¯å·®
                        const expectedX = canvasX - dragState.value.offset.x
                        const expectedY = canvasY - dragState.value.offset.y
                        const error = Math.sqrt(
                            Math.pow(boundedX - expectedX, 2) + 
                            Math.pow(boundedY - expectedY, 2)
                        )
                        
                        touchStats.value.precisionErrors.push(error)
                        if (touchStats.value.precisionErrors.length > 10) {
                            touchStats.value.precisionErrors.shift()
                        }
                    }
                }
                
                const onDocumentTouchEnd = (event) => {
                    endNodeDrag()
                }
                
                const onDocumentMouseEnd = (event) => {
                    endNodeDrag()
                }
                
                const endNodeDrag = () => {
                    if (!dragState.value.nodeId) return
                    
                    const node = nodes.value.find(n => n.id === dragState.value.nodeId)
                    if (node) {
                        node.touchFeedback = false
                    }
                    
                    dragState.value = { nodeId: null, startPos: null, offset: null }
                    
                    // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
                    document.removeEventListener('touchmove', onDocumentTouchMove)
                    document.removeEventListener('touchend', onDocumentTouchEnd)
                    document.removeEventListener('mousemove', onDocumentMouseMove)
                    document.removeEventListener('mouseup', onDocumentMouseEnd)
                    
                    console.log('ç»“æŸæ‹–æ‹½')
                }
                
                const handleCanvasClick = (event) => {
                    if (event.target === canvas.value) {
                        // åœ¨ç‚¹å‡»ä½ç½®åˆ›å»ºæ–°èŠ‚ç‚¹
                        const rect = canvas.value.getBoundingClientRect()
                        const canvasX = event.clientX - rect.left
                        const canvasY = event.clientY - rect.top
                        
                        const emojis = ['ğŸ¯', 'ğŸš€', 'â­', 'ğŸ’', 'ğŸ”¥']
                        const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6']
                        
                        const node = {
                            id: `node_${++nodeIdCounter}`,
                            position: { x: canvasX, y: canvasY },
                            emoji: emojis[Math.floor(Math.random() * emojis.length)],
                            color: colors[Math.floor(Math.random() * colors.length)],
                            label: `èŠ‚ç‚¹ ${nodeIdCounter}`,
                            touchFeedback: false
                        }
                        
                        nodes.value.push(node)
                    }
                }
                
                const createTouchRipple = (x, y) => {
                    const ripple = {
                        id: Date.now() + Math.random(),
                        x,
                        y
                    }
                    
                    touchRipples.value.push(ripple)
                    
                    setTimeout(() => {
                        const index = touchRipples.value.findIndex(r => r.id === ripple.id)
                        if (index !== -1) {
                            touchRipples.value.splice(index, 1)
                        }
                    }, 600)
                }
                
                const addTrailPoint = (x, y, touchId) => {
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6']
                    const trail = {
                        x,
                        y,
                        color: colors[touchId % colors.length],
                        opacity: 0.7,
                        timestamp: Date.now()
                    }
                    
                    touchTrails.value.push(trail)
                    
                    // é™åˆ¶è½¨è¿¹ç‚¹æ•°é‡
                    if (touchTrails.value.length > 100) {
                        touchTrails.value.shift()
                    }
                }
                
                const runTouchTest = async () => {
                    console.log('å¼€å§‹è‡ªåŠ¨è§¦æ§æµ‹è¯•...')
                    
                    // é‡ç½®æµ‹è¯•ç»“æœ
                    Object.keys(testResults.value).forEach(key => {
                        testResults.value[key] = false
                    })
                    
                    // æµ‹è¯•1: å•ç‚¹è§¦æ§
                    testResults.value['å•ç‚¹è§¦æ§'] = deviceInfo.value.maxTouchPoints > 0
                    
                    // æµ‹è¯•2: å¤šç‚¹è§¦æ§
                    testResults.value['å¤šç‚¹è§¦æ§'] = deviceInfo.value.maxTouchPoints > 1
                    
                    // æµ‹è¯•3: å‹åŠ›æ£€æµ‹
                    testResults.value['å‹åŠ›æ£€æµ‹'] = deviceInfo.value.supportsPressure
                    
                    // æµ‹è¯•4: æ‹–æ‹½ç²¾åº¦
                    const avgError = touchStats.value.precisionErrors.reduce((sum, error) => sum + error, 0) / 
                                   Math.max(touchStats.value.precisionErrors.length, 1)
                    testResults.value['æ‹–æ‹½ç²¾åº¦'] = avgError < 10
                    
                    // æµ‹è¯•5: æ€§èƒ½æµ‹è¯•
                    testResults.value['æ€§èƒ½æµ‹è¯•'] = performanceMetrics.value.fps > 30
                    
                    // æµ‹è¯•6: æ‰‹åŠ¿è¯†åˆ«
                    testResults.value['æ‰‹åŠ¿è¯†åˆ«'] = touchStats.value.gestureEvents > 0
                    
                    console.log('æµ‹è¯•å®Œæˆ:', testResults.value)
                }
                
                const startPerformanceMonitoring = () => {
                    let lastFrameTime = performance.now()
                    let frameCount = 0
                    
                    const updatePerformance = () => {
                        const now = performance.now()
                        frameCount++
                        
                        if (now - lastFrameTime >= 1000) {
                            performanceMetrics.value.fps = frameCount
                            performanceMetrics.value.frameTime = (now - lastFrameTime) / frameCount
                            
                            // å†…å­˜ä½¿ç”¨æƒ…å†µ
                            if (performance.memory) {
                                const memInfo = performance.memory
                                performanceMetrics.value.memoryUsage = 
                                    (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100
                            }
                            
                            // è®¡ç®—å¹³å‡å»¶è¿Ÿ
                            if (touchStats.value.precisionErrors.length > 0) {
                                touchStats.value.averageLatency = 
                                    touchStats.value.precisionErrors.reduce((sum, error) => sum + error, 0) / 
                                    touchStats.value.precisionErrors.length
                            }
                            
                            frameCount = 0
                            lastFrameTime = now
                        }
                        
                        performanceMonitor = requestAnimationFrame(updatePerformance)
                    }
                    
                    performanceMonitor = requestAnimationFrame(updatePerformance)
                }
                
                const updateTime = () => {
                    currentTime.value = new Date().toLocaleTimeString()
                    setTimeout(updateTime, 1000)
                }
                
                // ç”Ÿå‘½å‘¨æœŸ
                onMounted(async () => {
                    await detectDeviceInfo()
                    
                    // æ·»åŠ åˆå§‹èŠ‚ç‚¹
                    for (let i = 0; i < 3; i++) {
                        addTestNode()
                    }
                    
                    // å¼€å§‹æ€§èƒ½ç›‘æ§
                    startPerformanceMonitoring()
                    
                    // æ¸…ç†è½¨è¿¹ç‚¹
                    trailCleanupInterval = setInterval(() => {
                        const now = Date.now()
                        touchTrails.value = touchTrails.value.filter(trail => 
                            now - trail.timestamp < 5000 // 5ç§’åæ¸…ç†
                        )
                    }, 1000)
                    
                    // å¼€å§‹æ—¶é—´æ›´æ–°
                    updateTime()
                    
                    // ç›‘å¬è®¾å¤‡æ–¹å‘å˜åŒ–
                    window.addEventListener('resize', () => {
                        detectDeviceInfo()
                    })
                    
                    console.log('ç§»åŠ¨ç«¯è§¦æ§æµ‹è¯•é¡µé¢å·²åˆå§‹åŒ–')
                    console.log('è®¾å¤‡ä¿¡æ¯:', deviceInfo.value)
                })
                
                onUnmounted(() => {
                    if (performanceMonitor) {
                        cancelAnimationFrame(performanceMonitor)
                    }
                    
                    if (trailCleanupInterval) {
                        clearInterval(trailCleanupInterval)
                    }
                    
                    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
                    document.removeEventListener('touchmove', onDocumentTouchMove)
                    document.removeEventListener('touchend', onDocumentTouchEnd)
                    document.removeEventListener('mousemove', onDocumentMouseMove)
                    document.removeEventListener('mouseup', onDocumentMouseEnd)
                })
                
                return {
                    // çŠ¶æ€
                    nodes,
                    dragState,
                    showDebugPanel,
                    canvas,
                    currentTime,
                    activeTouches,
                    touchTrails,
                    activeGestures,
                    touchRipples,
                    
                    // é…ç½®
                    testConfig,
                    
                    // è®¾å¤‡ä¿¡æ¯
                    deviceInfo,
                    performanceMetrics,
                    touchStats,
                    testResults,
                    
                    // è®¡ç®—å±æ€§
                    canvasSize,
                    isLowPerformanceMode,
                    
                    // æ–¹æ³•
                    addTestNode,
                    clearNodes,
                    getNodeColor,
                    getPrecisionColor,
                    runTouchTest,
                    handleTouchStart,
                    handleTouchMove,
                    handleTouchEnd,
                    handleTouchCancel,
                    startNodeDrag,
                    handleCanvasClick
                }
            }
        }).mount('#app')
    </script>
</body>
</html>