<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>📱 移动端触控测试 - Pathfinder</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        [v-cloak] { display: none; }
        
        /* 移动端专用样式 */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            margin: 0;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            overscroll-behavior: none;
            touch-action: pan-x pan-y;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* 触控节点样式 */
        .touch-node {
            cursor: grab;
            touch-action: none;
            will-change: transform;
            transition: transform 0.15s ease-out;
        }
        
        .touch-node:active,
        .touch-node.dragging {
            cursor: grabbing;
            transform: scale(1.1);
            filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.3));
            z-index: 1000;
        }
        
        .touch-node.touch-feedback {
            background: radial-gradient(circle at center, rgba(59, 130, 246, 0.2) 0%, transparent 70%);
        }
        
        /* 手势指示器 */
        .gesture-indicator {
            position: absolute;
            pointer-events: none;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.1);
            transform: translate(-50%, -50%);
            transition: all 0.2s ease;
        }
        
        /* 触控轨迹 */
        .touch-trail {
            position: absolute;
            pointer-events: none;
            width: 4px;
            height: 4px;
            background: #f59e0b;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.7;
        }
        
        /* 压力指示器 */
        .pressure-indicator {
            position: absolute;
            pointer-events: none;
            border: 2px solid #ef4444;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* 响应式断点 */
        @media (max-width: 767px) {
            .phone-only { display: block !important; }
            .tablet-only, .desktop-only { display: none !important; }
        }
        
        @media (min-width: 768px) and (max-width: 1023px) {
            .tablet-only { display: block !important; }
            .phone-only, .desktop-only { display: none !important; }
        }
        
        @media (min-width: 1024px) {
            .desktop-only { display: block !important; }
            .phone-only, .tablet-only { display: none !important; }
        }
        
        /* 性能指示器 */
        .performance-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            z-index: 9999;
        }
        
        /* 触控调试面板 */
        .debug-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        
        .debug-panel.visible {
            transform: translateY(0);
        }
        
        /* 设备方向提示 */
        .orientation-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            z-index: 10000;
            display: none;
        }
        
        @media (orientation: landscape) and (max-width: 767px) {
            .orientation-hint.show-landscape { display: block; }
        }
        
        /* 动画和过渡 */
        @keyframes touchRipple {
            0% { transform: scale(0.8) translate(-50%, -50%); opacity: 1; }
            100% { transform: scale(2) translate(-50%, -50%); opacity: 0; }
        }
        
        .touch-ripple {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(59, 130, 246, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: touchRipple 0.6s ease-out;
        }
        
        /* 低性能模式 */
        .low-performance-mode * {
            transition: none !important;
            animation: none !important;
            filter: none !important;
        }
    </style>
</head>
<body>
    <div id="app" v-cloak>
        <!-- 性能指示器 -->
        <div class="performance-indicator">
            <div>FPS: {{ performanceMetrics.fps }}</div>
            <div>内存: {{ performanceMetrics.memoryUsage.toFixed(1) }}%</div>
            <div>电池: {{ deviceInfo.batteryLevel ? (deviceInfo.batteryLevel * 100).toFixed(0) + '%' : 'N/A' }}</div>
            <div>延迟: {{ performanceMetrics.latency.toFixed(0) }}ms</div>
        </div>
        
        <!-- 设备方向提示 -->
        <div class="orientation-hint show-landscape">
            <div class="text-lg font-bold mb-2">📱 请旋转设备</div>
            <div class="text-sm">为了更好的体验，请使用竖屏模式</div>
        </div>
        
        <!-- 主头部 -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-4 shadow-lg">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-xl font-bold">📱 移动端触控测试</h1>
                    <p class="text-sm opacity-90">{{ deviceInfo.deviceType.toUpperCase() }} - {{ deviceInfo.orientation.toUpperCase() }}</p>
                </div>
                <div class="text-right">
                    <div class="text-sm">{{ currentTime }}</div>
                    <div class="text-xs opacity-75">{{ touchStats.activeTouches }} 个触点</div>
                </div>
            </div>
        </div>

        <!-- 快速控制栏 -->
        <div class="bg-white border-b border-gray-200 p-2">
            <div class="flex items-center justify-between">
                <div class="flex space-x-2">
                    <button @click="addTestNode" class="px-3 py-2 bg-blue-500 text-white rounded-lg text-sm font-medium">
                        ➕ 添加节点
                    </button>
                    <button @click="clearNodes" class="px-3 py-2 bg-red-500 text-white rounded-lg text-sm font-medium">
                        🗑️ 清空
                    </button>
                    <button @click="runTouchTest" class="px-3 py-2 bg-green-500 text-white rounded-lg text-sm font-medium">
                        🧪 自动测试
                    </button>
                </div>
                <div class="flex items-center space-x-2">
                    <button @click="showDebugPanel = !showDebugPanel" class="px-2 py-1 bg-gray-600 text-white rounded text-xs">
                        {{ showDebugPanel ? '隐藏' : '调试' }}
                    </button>
                    <div class="text-xs text-gray-600">
                        节点: {{ nodes.length }}
                    </div>
                </div>
            </div>
        </div>

        <!-- 测试配置 -->
        <div class="bg-gray-50 p-3 border-b">
            <div class="grid grid-cols-2 gap-3 text-sm">
                <label class="flex items-center justify-between">
                    <span>显示轨迹</span>
                    <input v-model="testConfig.showTrails" type="checkbox" class="rounded">
                </label>
                <label class="flex items-center justify-between">
                    <span>压力检测</span>
                    <input v-model="testConfig.enablePressure" type="checkbox" class="rounded">
                </label>
                <label class="flex items-center justify-between">
                    <span>多点触控</span>
                    <input v-model="testConfig.enableMultiTouch" type="checkbox" class="rounded">
                </label>
                <label class="flex items-center justify-between">
                    <span>性能优化</span>
                    <input v-model="testConfig.enablePerformanceMode" type="checkbox" class="rounded">
                </label>
            </div>
        </div>

        <!-- 测试画布 -->
        <div class="flex-1 relative overflow-hidden" :class="{ 'low-performance-mode': isLowPerformanceMode }">
            <!-- SVG 画布 -->
            <svg 
                ref="canvas" 
                class="w-full h-full bg-gradient-to-br from-blue-50 to-purple-50"
                @touchstart="handleTouchStart"
                @touchmove="handleTouchMove"
                @touchend="handleTouchEnd"
                @touchcancel="handleTouchCancel"
                @click="handleCanvasClick"
                :viewBox="`0 0 ${canvasSize.width} ${canvasSize.height}`"
            >
                <!-- 网格背景 -->
                <defs>
                    <pattern id="touchGrid" width="40" height="40" patternUnits="userSpaceOnUse">
                        <circle cx="20" cy="20" r="1" fill="rgba(0,0,0,0.1)"/>
                    </pattern>
                </defs>
                <rect v-if="testConfig.showGrid" width="100%" height="100%" fill="url(#touchGrid)"/>
                
                <!-- 测试节点 -->
                <g class="test-nodes">
                    <g
                        v-for="node in nodes"
                        :key="node.id"
                        :class="[
                            'touch-node',
                            { 
                                'dragging': dragState.nodeId === node.id,
                                'touch-feedback': node.touchFeedback
                            }
                        ]"
                        :transform="`translate(${node.position.x}, ${node.position.y})`"
                        @touchstart.stop="startNodeDrag($event, node)"
                        @mousedown.stop="startNodeDrag($event, node)"
                    >
                        <!-- 节点主体 -->
                        <circle
                            r="30"
                            :fill="getNodeColor(node)"
                            stroke="white"
                            stroke-width="3"
                            class="drop-shadow-lg"
                        />
                        
                        <!-- 节点图标 -->
                        <text
                            text-anchor="middle"
                            dominant-baseline="middle"
                            class="text-lg font-bold fill-white pointer-events-none"
                        >
                            {{ node.emoji }}
                        </text>
                        
                        <!-- 触控精度指示器 -->
                        <circle
                            v-if="dragState.nodeId === node.id"
                            r="35"
                            fill="none"
                            :stroke="getPrecisionColor()"
                            stroke-width="2"
                            stroke-dasharray="5,5"
                            class="precision-indicator"
                        />
                        
                        <!-- 节点标签 -->
                        <text
                            y="50"
                            text-anchor="middle"
                            class="text-xs font-medium fill-gray-700 pointer-events-none"
                        >
                            {{ node.label }}
                        </text>
                        
                        <!-- 触控目标大小指示 -->
                        <circle
                            v-if="testConfig.showTouchTargets"
                            r="22"
                            fill="none"
                            stroke="rgba(59, 130, 246, 0.3)"
                            stroke-width="1"
                            stroke-dasharray="2,2"
                        />
                    </g>
                </g>
                
                <!-- 触控轨迹 -->
                <g v-if="testConfig.showTrails" class="touch-trails">
                    <circle
                        v-for="(trail, index) in touchTrails"
                        :key="index"
                        :cx="trail.x"
                        :cy="trail.y"
                        r="2"
                        :fill="trail.color"
                        :opacity="trail.opacity"
                    />
                </g>
            </svg>
            
            <!-- 手势指示器 -->
            <div
                v-for="gesture in activeGestures"
                :key="gesture.id"
                class="gesture-indicator"
                :style="{
                    left: gesture.center.x + 'px',
                    top: gesture.center.y + 'px',
                    width: (gesture.size || 40) + 'px',
                    height: (gesture.size || 40) + 'px'
                }"
            ></div>
            
            <!-- 压力指示器 -->
            <div
                v-for="touch in activeTouches"
                :key="'pressure-' + touch.id"
                v-if="testConfig.enablePressure && touch.pressure > 0"
                class="pressure-indicator"
                :style="{
                    left: touch.position.x + 'px',
                    top: touch.position.y + 'px',
                    width: (touch.pressure * 50) + 'px',
                    height: (touch.pressure * 50) + 'px',
                    opacity: touch.pressure
                }"
            ></div>
            
            <!-- 触控涟漪效果 -->
            <div
                v-for="ripple in touchRipples"
                :key="ripple.id"
                class="touch-ripple"
                :style="{ left: ripple.x + 'px', top: ripple.y + 'px' }"
            ></div>
        </div>

        <!-- 调试面板 -->
        <div :class="['debug-panel', { visible: showDebugPanel }]">
            <div class="mb-2 font-bold">🔧 触控调试信息</div>
            <div class="grid grid-cols-2 gap-4 text-xs">
                <div>
                    <div class="font-medium text-blue-300 mb-1">设备信息</div>
                    <div>类型: {{ deviceInfo.deviceType }}</div>
                    <div>尺寸: {{ deviceInfo.screenSize.width }}×{{ deviceInfo.screenSize.height }}</div>
                    <div>像素比: {{ deviceInfo.devicePixelRatio }}x</div>
                    <div>最大触点: {{ deviceInfo.maxTouchPoints }}</div>
                    <div>支持压力: {{ deviceInfo.supportsPressure ? '是' : '否' }}</div>
                </div>
                <div>
                    <div class="font-medium text-green-300 mb-1">触控统计</div>
                    <div>活跃触点: {{ touchStats.activeTouches }}</div>
                    <div>总触控数: {{ touchStats.totalTouches }}</div>
                    <div>拖拽事件: {{ touchStats.dragEvents }}</div>
                    <div>手势识别: {{ touchStats.gestureEvents }}</div>
                    <div>平均延迟: {{ touchStats.averageLatency.toFixed(1) }}ms</div>
                </div>
            </div>
            <div class="mt-2">
                <div class="font-medium text-yellow-300 mb-1">测试结果</div>
                <div class="flex flex-wrap gap-2">
                    <span v-for="(result, test) in testResults" :key="test"
                          :class="[
                              'px-2 py-1 rounded text-xs',
                              result ? 'bg-green-600' : 'bg-red-600'
                          ]">
                        {{ test }}: {{ result ? '✓' : '✗' }}
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, nextTick } = Vue

        createApp({
            setup() {
                // 状态管理
                const nodes = ref([])
                const dragState = ref({ nodeId: null, startPos: null, offset: null })
                const showDebugPanel = ref(false)
                const canvas = ref(null)
                const currentTime = ref(new Date().toLocaleTimeString())
                
                // 触控相关状态
                const activeTouches = ref([])
                const touchTrails = ref([])
                const activeGestures = ref([])
                const touchRipples = ref([])
                
                // 配置
                const testConfig = ref({
                    showTrails: true,
                    enablePressure: true,
                    enableMultiTouch: true,
                    enablePerformanceMode: true,
                    showGrid: true,
                    showTouchTargets: false
                })
                
                // 设备信息
                const deviceInfo = ref({
                    deviceType: 'unknown',
                    orientation: 'unknown',
                    screenSize: { width: 0, height: 0 },
                    devicePixelRatio: 1,
                    maxTouchPoints: 0,
                    supportsPressure: false,
                    batteryLevel: null
                })
                
                // 性能指标
                const performanceMetrics = ref({
                    fps: 60,
                    memoryUsage: 0,
                    latency: 0,
                    frameTime: 0
                })
                
                // 触控统计
                const touchStats = ref({
                    activeTouches: 0,
                    totalTouches: 0,
                    dragEvents: 0,
                    gestureEvents: 0,
                    averageLatency: 0,
                    precisionErrors: []
                })
                
                // 测试结果
                const testResults = ref({
                    '单点触控': false,
                    '多点触控': false,
                    '拖拽精度': false,
                    '压力检测': false,
                    '手势识别': false,
                    '性能测试': false
                })
                
                let nodeIdCounter = 0
                let performanceMonitor = null
                let trailCleanupInterval = null
                
                // 计算属性
                const canvasSize = computed(() => ({
                    width: window.innerWidth,
                    height: window.innerHeight - 200 // 减去头部和控制栏
                }))
                
                const isLowPerformanceMode = computed(() => 
                    testConfig.value.enablePerformanceMode && 
                    (performanceMetrics.value.fps < 30 || performanceMetrics.value.memoryUsage > 80)
                )
                
                // 方法
                const detectDeviceInfo = async () => {
                    // 检测设备类型
                    const width = window.innerWidth
                    let deviceType = 'desktop'
                    if (width < 768) deviceType = 'phone'
                    else if (width < 1024) deviceType = 'tablet'
                    
                    // 检测屏幕方向
                    const orientation = width > window.innerHeight ? 'landscape' : 'portrait'
                    
                    deviceInfo.value = {
                        deviceType,
                        orientation,
                        screenSize: { width: window.innerWidth, height: window.innerHeight },
                        devicePixelRatio: window.devicePixelRatio || 1,
                        maxTouchPoints: navigator.maxTouchPoints || 0,
                        supportsPressure: 'force' in Touch.prototype || 'webkitForce' in Touch.prototype,
                        batteryLevel: null
                    }
                    
                    // 检测电池信息
                    try {
                        if ('getBattery' in navigator) {
                            const battery = await navigator.getBattery()
                            deviceInfo.value.batteryLevel = battery.level
                        }
                    } catch (e) {
                        // 电池API可能不可用
                    }
                }
                
                const addTestNode = () => {
                    const emojis = ['🎯', '🚀', '⭐', '💎', '🔥', '⚡', '🎨', '🎪', '🎭', '🎨']
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899']
                    
                    const node = {
                        id: `node_${++nodeIdCounter}`,
                        position: {
                            x: Math.random() * (canvasSize.value.width - 100) + 50,
                            y: Math.random() * (canvasSize.value.height - 100) + 50
                        },
                        emoji: emojis[Math.floor(Math.random() * emojis.length)],
                        color: colors[Math.floor(Math.random() * colors.length)],
                        label: `节点 ${nodeIdCounter}`,
                        touchFeedback: false
                    }
                    
                    nodes.value.push(node)
                }
                
                const clearNodes = () => {
                    nodes.value = []
                    nodeIdCounter = 0
                }
                
                const getNodeColor = (node) => {
                    if (dragState.value.nodeId === node.id) {
                        return '#1d4ed8' // 拖拽时的颜色
                    }
                    return node.color
                }
                
                const getPrecisionColor = () => {
                    const error = touchStats.value.precisionErrors[touchStats.value.precisionErrors.length - 1] || 0
                    if (error < 5) return '#10b981' // 绿色 - 高精度
                    if (error < 10) return '#f59e0b' // 黄色 - 中等精度
                    return '#ef4444' // 红色 - 低精度
                }
                
                const handleTouchStart = (event) => {
                    event.preventDefault()
                    const startTime = performance.now()
                    
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i]
                        
                        const touchInfo = {
                            id: touch.identifier,
                            position: { x: touch.clientX, y: touch.clientY },
                            pressure: touch.force || touch.webkitForce || 0.5,
                            timestamp: startTime
                        }
                        
                        activeTouches.value.push(touchInfo)
                        
                        // 创建触控涟漪
                        if (testConfig.value.showTrails) {
                            createTouchRipple(touch.clientX, touch.clientY)
                        }
                    }
                    
                    touchStats.value.activeTouches = activeTouches.value.length
                    touchStats.value.totalTouches++
                    
                    // 更新性能指标
                    performanceMetrics.value.latency = performance.now() - startTime
                }
                
                const handleTouchMove = (event) => {
                    event.preventDefault()
                    
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i]
                        const touchIndex = activeTouches.value.findIndex(t => t.id === touch.identifier)
                        
                        if (touchIndex !== -1) {
                            const oldPos = activeTouches.value[touchIndex].position
                            activeTouches.value[touchIndex].position = { x: touch.clientX, y: touch.clientY }
                            activeTouches.value[touchIndex].pressure = touch.force || touch.webkitForce || 0.5
                            
                            // 添加轨迹点
                            if (testConfig.value.showTrails) {
                                addTrailPoint(touch.clientX, touch.clientY, touch.identifier)
                            }
                        }
                    }
                }
                
                const handleTouchEnd = (event) => {
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i]
                        const touchIndex = activeTouches.value.findIndex(t => t.id === touch.identifier)
                        
                        if (touchIndex !== -1) {
                            activeTouches.value.splice(touchIndex, 1)
                        }
                    }
                    
                    touchStats.value.activeTouches = activeTouches.value.length
                    
                    // 结束拖拽
                    if (dragState.value.nodeId) {
                        endNodeDrag()
                    }
                }
                
                const handleTouchCancel = (event) => {
                    activeTouches.value = []
                    touchStats.value.activeTouches = 0
                    
                    if (dragState.value.nodeId) {
                        endNodeDrag()
                    }
                }
                
                const startNodeDrag = (event, node) => {
                    event.preventDefault()
                    event.stopPropagation()
                    
                    const startTime = performance.now()
                    
                    // 获取触控或鼠标位置
                    let clientX, clientY
                    if (event.type === 'touchstart') {
                        const touch = event.touches[0]
                        clientX = touch.clientX
                        clientY = touch.clientY
                    } else {
                        clientX = event.clientX
                        clientY = event.clientY
                    }
                    
                    // 计算偏移
                    const rect = canvas.value.getBoundingClientRect()
                    const canvasX = clientX - rect.left
                    const canvasY = clientY - rect.top
                    
                    dragState.value = {
                        nodeId: node.id,
                        startPos: { x: canvasX, y: canvasY },
                        offset: {
                            x: canvasX - node.position.x,
                            y: canvasY - node.position.y
                        }
                    }
                    
                    // 添加触控反馈
                    node.touchFeedback = true
                    
                    touchStats.value.dragEvents++
                    
                    // 监听文档级别的移动和结束事件
                    document.addEventListener('touchmove', onDocumentTouchMove, { passive: false })
                    document.addEventListener('touchend', onDocumentTouchEnd)
                    document.addEventListener('mousemove', onDocumentMouseMove)
                    document.addEventListener('mouseup', onDocumentMouseEnd)
                    
                    console.log('开始拖拽节点:', node.id)
                }
                
                const onDocumentTouchMove = (event) => {
                    if (!dragState.value.nodeId) return
                    
                    event.preventDefault()
                    const touch = event.touches[0]
                    if (!touch) return
                    
                    updateNodePosition(touch.clientX, touch.clientY)
                }
                
                const onDocumentMouseMove = (event) => {
                    if (!dragState.value.nodeId) return
                    
                    event.preventDefault()
                    updateNodePosition(event.clientX, event.clientY)
                }
                
                const updateNodePosition = (clientX, clientY) => {
                    const rect = canvas.value.getBoundingClientRect()
                    const canvasX = clientX - rect.left
                    const canvasY = clientY - rect.top
                    
                    const newX = canvasX - dragState.value.offset.x
                    const newY = canvasY - dragState.value.offset.y
                    
                    // 边界检测
                    const boundedX = Math.max(30, Math.min(newX, canvasSize.value.width - 30))
                    const boundedY = Math.max(30, Math.min(newY, canvasSize.value.height - 30))
                    
                    // 更新节点位置
                    const node = nodes.value.find(n => n.id === dragState.value.nodeId)
                    if (node) {
                        node.position.x = boundedX
                        node.position.y = boundedY
                        
                        // 计算精度误差
                        const expectedX = canvasX - dragState.value.offset.x
                        const expectedY = canvasY - dragState.value.offset.y
                        const error = Math.sqrt(
                            Math.pow(boundedX - expectedX, 2) + 
                            Math.pow(boundedY - expectedY, 2)
                        )
                        
                        touchStats.value.precisionErrors.push(error)
                        if (touchStats.value.precisionErrors.length > 10) {
                            touchStats.value.precisionErrors.shift()
                        }
                    }
                }
                
                const onDocumentTouchEnd = (event) => {
                    endNodeDrag()
                }
                
                const onDocumentMouseEnd = (event) => {
                    endNodeDrag()
                }
                
                const endNodeDrag = () => {
                    if (!dragState.value.nodeId) return
                    
                    const node = nodes.value.find(n => n.id === dragState.value.nodeId)
                    if (node) {
                        node.touchFeedback = false
                    }
                    
                    dragState.value = { nodeId: null, startPos: null, offset: null }
                    
                    // 移除事件监听器
                    document.removeEventListener('touchmove', onDocumentTouchMove)
                    document.removeEventListener('touchend', onDocumentTouchEnd)
                    document.removeEventListener('mousemove', onDocumentMouseMove)
                    document.removeEventListener('mouseup', onDocumentMouseEnd)
                    
                    console.log('结束拖拽')
                }
                
                const handleCanvasClick = (event) => {
                    if (event.target === canvas.value) {
                        // 在点击位置创建新节点
                        const rect = canvas.value.getBoundingClientRect()
                        const canvasX = event.clientX - rect.left
                        const canvasY = event.clientY - rect.top
                        
                        const emojis = ['🎯', '🚀', '⭐', '💎', '🔥']
                        const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6']
                        
                        const node = {
                            id: `node_${++nodeIdCounter}`,
                            position: { x: canvasX, y: canvasY },
                            emoji: emojis[Math.floor(Math.random() * emojis.length)],
                            color: colors[Math.floor(Math.random() * colors.length)],
                            label: `节点 ${nodeIdCounter}`,
                            touchFeedback: false
                        }
                        
                        nodes.value.push(node)
                    }
                }
                
                const createTouchRipple = (x, y) => {
                    const ripple = {
                        id: Date.now() + Math.random(),
                        x,
                        y
                    }
                    
                    touchRipples.value.push(ripple)
                    
                    setTimeout(() => {
                        const index = touchRipples.value.findIndex(r => r.id === ripple.id)
                        if (index !== -1) {
                            touchRipples.value.splice(index, 1)
                        }
                    }, 600)
                }
                
                const addTrailPoint = (x, y, touchId) => {
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6']
                    const trail = {
                        x,
                        y,
                        color: colors[touchId % colors.length],
                        opacity: 0.7,
                        timestamp: Date.now()
                    }
                    
                    touchTrails.value.push(trail)
                    
                    // 限制轨迹点数量
                    if (touchTrails.value.length > 100) {
                        touchTrails.value.shift()
                    }
                }
                
                const runTouchTest = async () => {
                    console.log('开始自动触控测试...')
                    
                    // 重置测试结果
                    Object.keys(testResults.value).forEach(key => {
                        testResults.value[key] = false
                    })
                    
                    // 测试1: 单点触控
                    testResults.value['单点触控'] = deviceInfo.value.maxTouchPoints > 0
                    
                    // 测试2: 多点触控
                    testResults.value['多点触控'] = deviceInfo.value.maxTouchPoints > 1
                    
                    // 测试3: 压力检测
                    testResults.value['压力检测'] = deviceInfo.value.supportsPressure
                    
                    // 测试4: 拖拽精度
                    const avgError = touchStats.value.precisionErrors.reduce((sum, error) => sum + error, 0) / 
                                   Math.max(touchStats.value.precisionErrors.length, 1)
                    testResults.value['拖拽精度'] = avgError < 10
                    
                    // 测试5: 性能测试
                    testResults.value['性能测试'] = performanceMetrics.value.fps > 30
                    
                    // 测试6: 手势识别
                    testResults.value['手势识别'] = touchStats.value.gestureEvents > 0
                    
                    console.log('测试完成:', testResults.value)
                }
                
                const startPerformanceMonitoring = () => {
                    let lastFrameTime = performance.now()
                    let frameCount = 0
                    
                    const updatePerformance = () => {
                        const now = performance.now()
                        frameCount++
                        
                        if (now - lastFrameTime >= 1000) {
                            performanceMetrics.value.fps = frameCount
                            performanceMetrics.value.frameTime = (now - lastFrameTime) / frameCount
                            
                            // 内存使用情况
                            if (performance.memory) {
                                const memInfo = performance.memory
                                performanceMetrics.value.memoryUsage = 
                                    (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100
                            }
                            
                            // 计算平均延迟
                            if (touchStats.value.precisionErrors.length > 0) {
                                touchStats.value.averageLatency = 
                                    touchStats.value.precisionErrors.reduce((sum, error) => sum + error, 0) / 
                                    touchStats.value.precisionErrors.length
                            }
                            
                            frameCount = 0
                            lastFrameTime = now
                        }
                        
                        performanceMonitor = requestAnimationFrame(updatePerformance)
                    }
                    
                    performanceMonitor = requestAnimationFrame(updatePerformance)
                }
                
                const updateTime = () => {
                    currentTime.value = new Date().toLocaleTimeString()
                    setTimeout(updateTime, 1000)
                }
                
                // 生命周期
                onMounted(async () => {
                    await detectDeviceInfo()
                    
                    // 添加初始节点
                    for (let i = 0; i < 3; i++) {
                        addTestNode()
                    }
                    
                    // 开始性能监控
                    startPerformanceMonitoring()
                    
                    // 清理轨迹点
                    trailCleanupInterval = setInterval(() => {
                        const now = Date.now()
                        touchTrails.value = touchTrails.value.filter(trail => 
                            now - trail.timestamp < 5000 // 5秒后清理
                        )
                    }, 1000)
                    
                    // 开始时间更新
                    updateTime()
                    
                    // 监听设备方向变化
                    window.addEventListener('resize', () => {
                        detectDeviceInfo()
                    })
                    
                    console.log('移动端触控测试页面已初始化')
                    console.log('设备信息:', deviceInfo.value)
                })
                
                onUnmounted(() => {
                    if (performanceMonitor) {
                        cancelAnimationFrame(performanceMonitor)
                    }
                    
                    if (trailCleanupInterval) {
                        clearInterval(trailCleanupInterval)
                    }
                    
                    // 清理事件监听器
                    document.removeEventListener('touchmove', onDocumentTouchMove)
                    document.removeEventListener('touchend', onDocumentTouchEnd)
                    document.removeEventListener('mousemove', onDocumentMouseMove)
                    document.removeEventListener('mouseup', onDocumentMouseEnd)
                })
                
                return {
                    // 状态
                    nodes,
                    dragState,
                    showDebugPanel,
                    canvas,
                    currentTime,
                    activeTouches,
                    touchTrails,
                    activeGestures,
                    touchRipples,
                    
                    // 配置
                    testConfig,
                    
                    // 设备信息
                    deviceInfo,
                    performanceMetrics,
                    touchStats,
                    testResults,
                    
                    // 计算属性
                    canvasSize,
                    isLowPerformanceMode,
                    
                    // 方法
                    addTestNode,
                    clearNodes,
                    getNodeColor,
                    getPrecisionColor,
                    runTouchTest,
                    handleTouchStart,
                    handleTouchMove,
                    handleTouchEnd,
                    handleTouchCancel,
                    startNodeDrag,
                    handleCanvasClick
                }
            }
        }).mount('#app')
    </script>
</body>
</html>