<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš€ Pathfinder æ¼æ–—æ„å»ºå™¨ - å®Œæ•´åŠŸèƒ½å±•ç¤º</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        [v-cloak] { display: none; }
        
        /* Enhanced animation styles */
        .flow-particle {
            filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.3));
            will-change: transform, opacity;
        }
        
        .flow-intensity {
            transition: all 0.3s ease;
        }
        
        .node-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .funnel-node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .funnel-node:hover {
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.3));
        }
        
        .funnel-node.selected {
            filter: drop-shadow(0 0 12px rgba(59, 130, 246, 0.8));
        }
        
        .connection-line {
            stroke-width: 2;
            fill: none;
            transition: all 0.2s ease;
        }
        
        .bottleneck-indicator {
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .bottleneck-indicator:hover {
            transform: scale(1.1);
        }
        
        /* Smart layout animations */
        .layout-transition {
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }
        
        /* Success animations */
        @keyframes checkmark {
            0% { transform: scale(0) rotate(45deg); }
            50% { transform: scale(1.2) rotate(45deg); }
            100% { transform: scale(1) rotate(45deg); }
        }
        
        .success-checkmark {
            animation: checkmark 0.6s ease-in-out;
        }
        
        /* Feature highlight */
        .feature-highlight {
            position: relative;
            overflow: hidden;
        }
        
        .feature-highlight::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-blue-50 min-h-screen">
    <div id="app" v-cloak>
        <!-- Hero Section -->
        <div class="bg-white shadow-sm border-b border-gray-200">
            <div class="max-w-7xl mx-auto px-4 py-8">
                <div class="text-center">
                    <h1 class="text-4xl font-bold text-gray-900 mb-4">
                        ğŸš€ Pathfinder æ¼æ–—æ„å»ºå™¨
                    </h1>
                    <p class="text-xl text-gray-600 mb-6">
                        ä¸“ä¸šçº§æ‹–æ‹½å¼æ¼æ–—æ„å»ºå™¨ - é›†æˆæ™ºèƒ½å¸ƒå±€ã€å®æ—¶æ•°æ®æµå¯è§†åŒ–å’Œæ€§èƒ½åˆ†æ
                    </p>
                    <div class="flex justify-center items-center space-x-8 text-sm text-gray-500">
                        <div class="flex items-center space-x-2">
                            <div class="w-3 h-3 rounded-full bg-green-500"></div>
                            <span>Vue 3 + TypeScript</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div class="w-3 h-3 rounded-full bg-blue-500"></div>
                            <span>D3.js æ•°æ®å¯è§†åŒ–</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div class="w-3 h-3 rounded-full bg-purple-500"></div>
                            <span>æ™ºèƒ½å¸ƒå±€ç®—æ³•</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div class="w-3 h-3 rounded-full bg-orange-500"></div>
                            <span>å®æ—¶æ•°æ®æµ</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Application -->
        <div class="flex h-screen">
            <!-- Left Sidebar: Feature Controls -->
            <div class="w-80 bg-white border-r border-gray-200 shadow-sm overflow-y-auto">
                <!-- Node Palette -->
                <div class="p-6 border-b border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">ğŸ¨ èŠ‚ç‚¹å·¥å…·ç®±</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div 
                            v-for="nodeType in nodeTypes" 
                            :key="nodeType.type"
                            class="feature-highlight p-3 border-2 border-dashed border-gray-200 rounded-lg hover:border-blue-300 hover:bg-blue-50 transition-all cursor-pointer"
                            draggable="true"
                            @dragstart="handleNodeDragStart($event, nodeType)"
                            @dragend="handleNodeDragEnd"
                        >
                            <div class="flex items-center space-x-2">
                                <div 
                                    :class="[
                                        'w-8 h-8 rounded-lg flex items-center justify-center text-white shadow-sm',
                                        nodeType.color
                                    ]"
                                >
                                    <span class="text-sm font-bold">{{ nodeType.icon }}</span>
                                </div>
                                <div class="flex-1 min-w-0">
                                    <h4 class="text-sm font-medium text-gray-900 truncate">{{ nodeType.label }}</h4>
                                    <p class="text-xs text-gray-500 truncate">{{ nodeType.description }}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Smart Layout Controls -->
                <div class="p-6 border-b border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">ğŸ§  æ™ºèƒ½å¸ƒå±€</h3>
                    <div class="space-y-3">
                        <button 
                            @click="applyLayout('hierarchical')"
                            class="w-full flex items-center space-x-3 p-3 bg-gradient-to-r from-green-50 to-green-100 border border-green-200 rounded-lg hover:from-green-100 hover:to-green-200 transition-all"
                        >
                            <span class="text-xl">ğŸŒ²</span>
                            <div class="text-left">
                                <div class="text-sm font-medium text-green-900">å±‚æ¬¡å¸ƒå±€</div>
                                <div class="text-xs text-green-700">è‡ªåŠ¨æ’åˆ—èŠ‚ç‚¹å±‚çº§</div>
                            </div>
                        </button>
                        <button 
                            @click="applyLayout('force')"
                            class="w-full flex items-center space-x-3 p-3 bg-gradient-to-r from-blue-50 to-blue-100 border border-blue-200 rounded-lg hover:from-blue-100 hover:to-blue-200 transition-all"
                        >
                            <span class="text-xl">ğŸ”—</span>
                            <div class="text-left">
                                <div class="text-sm font-medium text-blue-900">åŠ›å¯¼å‘å¸ƒå±€</div>
                                <div class="text-xs text-blue-700">ç‰©ç†æ¨¡æ‹Ÿè‡ªç„¶æ’åˆ—</div>
                            </div>
                        </button>
                        <button 
                            @click="applyLayout('grid')"
                            class="w-full flex items-center space-x-3 p-3 bg-gradient-to-r from-purple-50 to-purple-100 border border-purple-200 rounded-lg hover:from-purple-100 hover:to-purple-200 transition-all"
                        >
                            <span class="text-xl">âš</span>
                            <div class="text-left">
                                <div class="text-sm font-medium text-purple-900">ç½‘æ ¼å¸ƒå±€</div>
                                <div class="text-xs text-purple-700">æ•´é½çš„çŸ©é˜µæ’åˆ—</div>
                            </div>
                        </button>
                        <button 
                            @click="applyLayout('circular')"
                            class="w-full flex items-center space-x-3 p-3 bg-gradient-to-r from-orange-50 to-orange-100 border border-orange-200 rounded-lg hover:from-orange-100 hover:to-orange-200 transition-all"
                        >
                            <span class="text-xl">â­•</span>
                            <div class="text-left">
                                <div class="text-sm font-medium text-orange-900">ç¯å½¢å¸ƒå±€</div>
                                <div class="text-xs text-orange-700">åœ†å½¢åˆ†å¸ƒæ’åˆ—</div>
                            </div>
                        </button>
                    </div>
                </div>

                <!-- Data Flow Controls -->
                <div class="p-6 border-b border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">ğŸ“Š æ•°æ®æµå¯è§†åŒ–</h3>
                    <div class="space-y-3">
                        <label class="flex items-center justify-between">
                            <span class="text-sm font-medium text-gray-700">æµåŠ¨ç”»æ•ˆæœ</span>
                            <input v-model="showFlowAnimation" type="checkbox" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        </label>
                        <label class="flex items-center justify-between">
                            <span class="text-sm font-medium text-gray-700">è½¬åŒ–ç‡æ˜¾ç¤º</span>
                            <input v-model="showConversionRates" type="checkbox" class="rounded border-gray-300 text-green-600 focus:ring-green-500">
                        </label>
                        <label class="flex items-center justify-between">
                            <span class="text-sm font-medium text-gray-700">æµé‡æŒ‡ç¤ºå™¨</span>
                            <input v-model="showVolumeIndicators" type="checkbox" class="rounded border-gray-300 text-purple-600 focus:ring-purple-500">
                        </label>
                        <label class="flex items-center justify-between">
                            <span class="text-sm font-medium text-gray-700">æ€§èƒ½åˆ†æ</span>
                            <input v-model="showPerformanceIndicators" type="checkbox" class="rounded border-gray-300 text-red-600 focus:ring-red-500">
                        </label>
                        <label class="flex items-center justify-between">
                            <span class="text-sm font-medium text-gray-700">ç“¶é¢ˆæ£€æµ‹</span>
                            <input v-model="showBottleneckAlerts" type="checkbox" class="rounded border-gray-300 text-yellow-600 focus:ring-yellow-500">
                        </label>
                        <label class="flex items-center justify-between">
                            <span class="text-sm font-medium text-gray-700">çƒ­åŠ›å›¾</span>
                            <input v-model="showHeatMap" type="checkbox" class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                        </label>
                    </div>
                    
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <label class="block text-sm font-medium text-gray-700 mb-2">åŠ¨ç”»é€Ÿåº¦</label>
                        <input 
                            v-model.number="animationSpeed" 
                            type="range" 
                            min="0.1" 
                            max="3" 
                            step="0.1" 
                            class="w-full"
                        />
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>æ…¢</span>
                            <span>{{ animationSpeed.toFixed(1) }}x</span>
                            <span>å¿«</span>
                        </div>
                    </div>
                </div>

                <!-- Demo Scenarios -->
                <div class="p-6">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">ğŸ¯ æ¼”ç¤ºåœºæ™¯</h3>
                    <div class="space-y-3">
                        <button 
                            @click="loadDemo('ecommerce')"
                            class="w-full p-3 text-left bg-gradient-to-r from-emerald-50 to-emerald-100 border border-emerald-200 rounded-lg hover:from-emerald-100 hover:to-emerald-200 transition-all"
                        >
                            <div class="font-medium text-emerald-900">ğŸ›’ ç”µå•†è´­ç‰©æ¼æ–—</div>
                            <div class="text-xs text-emerald-700 mt-1">å®Œæ•´çš„ç”µå•†è½¬åŒ–æµç¨‹</div>
                        </button>
                        <button 
                            @click="loadDemo('saas')"
                            class="w-full p-3 text-left bg-gradient-to-r from-sky-50 to-sky-100 border border-sky-200 rounded-lg hover:from-sky-100 hover:to-sky-200 transition-all"
                        >
                            <div class="font-medium text-sky-900">ğŸ’¼ SaaS æ³¨å†Œæµç¨‹</div>
                            <div class="text-xs text-sky-700 mt-1">ç”¨æˆ·æ³¨å†Œå’Œæ¿€æ´»æµç¨‹</div>
                        </button>
                        <button 
                            @click="loadDemo('complex')"
                            class="w-full p-3 text-left bg-gradient-to-r from-rose-50 to-rose-100 border border-rose-200 rounded-lg hover:from-rose-100 hover:to-rose-200 transition-all"
                        >
                            <div class="font-medium text-rose-900">ğŸ”¬ å¤æ‚åˆ†æåœºæ™¯</div>
                            <div class="text-xs text-rose-700 mt-1">50+ èŠ‚ç‚¹å¤§è§„æ¨¡æµ‹è¯•</div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Main Canvas Area -->
            <div class="flex-1 flex flex-col">
                <!-- Top Controls -->
                <div class="bg-white border-b border-gray-200 px-6 py-3">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-4">
                            <h2 class="text-lg font-semibold text-gray-900">æ¼æ–—ç”»å¸ƒ</h2>
                            <div class="flex items-center space-x-3 text-sm text-gray-500">
                                <span>èŠ‚ç‚¹: <strong class="text-gray-900">{{ nodes.length }}</strong></span>
                                <span>è¿æ¥: <strong class="text-gray-900">{{ edges.length }}</strong></span>
                                <span v-if="totalVisitors > 0">è®¿å®¢: <strong class="text-blue-600">{{ totalVisitors.toLocaleString() }}</strong></span>
                                <span v-if="overallConversionRate > 0">è½¬åŒ–ç‡: <strong class="text-green-600">{{ (overallConversionRate * 100).toFixed(1) }}%</strong></span>
                            </div>
                        </div>
                        
                        <div class="flex items-center space-x-2">
                            <!-- Canvas Controls -->
                            <button @click="resetView" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded transition-colors">
                                ğŸ¯ é‡ç½®è§†å›¾
                            </button>
                            <button @click="fitToView" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded transition-colors">
                                ğŸ” é€‚åº”ç”»å¸ƒ
                            </button>
                            <button @click="toggleGrid" :class="[
                                'px-3 py-1 text-sm rounded transition-colors',
                                showGrid ? 'bg-blue-100 text-blue-700 border border-blue-300' : 'bg-gray-100 hover:bg-gray-200'
                            ]">
                                âš {{ showGrid ? 'éšè—' : 'æ˜¾ç¤º' }}ç½‘æ ¼
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Canvas -->
                <div class="flex-1 relative bg-gray-50">
                    <svg 
                        ref="canvas" 
                        class="w-full h-full"
                        @dragover.prevent="handleCanvasDragOver"
                        @drop.prevent="handleCanvasDrop"
                        @click="handleCanvasClick"
                    >
                        <!-- Definitions -->
                        <defs>
                            <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="3" markerWidth="6" markerHeight="6" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#6b7280"/>
                            </marker>
                            <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e5e7eb" stroke-width="0.5" opacity="0.3"/>
                            </pattern>
                        </defs>

                        <!-- Grid Background -->
                        <rect v-if="showGrid" width="100%" height="100%" fill="url(#grid)"/>
                        
                        <!-- Main Container -->
                        <g ref="container" class="main-container">
                            <!-- Heat Map (if enabled) -->
                            <g v-if="showHeatMap" class="heat-map-layer">
                                <rect
                                    v-for="cell in heatMapCells"
                                    :key="cell.id"
                                    :x="cell.x"
                                    :y="cell.y"
                                    :width="cell.size"
                                    :height="cell.size"
                                    :fill="cell.color"
                                    :opacity="cell.intensity * 0.2"
                                    class="heat-cell"
                                />
                            </g>
                            
                            <!-- Connection Lines -->
                            <g class="edges">
                                <g v-for="edge in edges" :key="edge.id" class="edge-group">
                                    <!-- Base line -->
                                    <path
                                        :d="getConnectionPath(edge)"
                                        fill="none"
                                        :stroke="getEdgeColor(edge)"
                                        :stroke-width="getEdgeWidth(edge)"
                                        marker-end="url(#arrow)"
                                        class="connection-line"
                                    />
                                    
                                    <!-- Flow animation particles -->
                                    <g v-if="showFlowAnimation && getFlowData(edge.id)">
                                        <circle
                                            v-for="particle in getFlowParticles(edge)"
                                            :key="particle.id"
                                            :r="particle.size"
                                            :fill="particle.color"
                                            class="flow-particle"
                                        >
                                            <animateMotion
                                                :dur="particle.duration"
                                                :path="getConnectionPath(edge)"
                                                repeatCount="indefinite"
                                                :begin="particle.delay"
                                            />
                                            <animate
                                                attributeName="opacity"
                                                values="0.2;1;0.2"
                                                :dur="particle.duration"
                                                repeatCount="indefinite"
                                                :begin="particle.delay"
                                            />
                                        </circle>
                                    </g>
                                    
                                    <!-- Volume indicator -->
                                    <g v-if="showVolumeIndicators && getFlowData(edge.id)">
                                        <rect
                                            :x="getEdgeMidpoint(edge).x - 25"
                                            :y="getEdgeMidpoint(edge).y - 8"
                                            width="50"
                                            height="16"
                                            rx="8"
                                            fill="rgba(59, 130, 246, 0.9)"
                                        />
                                        <text
                                            :x="getEdgeMidpoint(edge).x"
                                            :y="getEdgeMidpoint(edge).y"
                                            text-anchor="middle"
                                            dominant-baseline="middle"
                                            class="text-xs font-bold fill-white"
                                        >
                                            {{ formatNumber(getFlowData(edge.id).volume) }}
                                        </text>
                                    </g>
                                </g>
                            </g>
                            
                            <!-- Nodes -->
                            <g class="nodes">
                                <g
                                    v-for="node in nodes"
                                    :key="node.id"
                                    :class="['funnel-node layout-transition', { 'selected': selectedNodeId === node.id }]"
                                    :transform="`translate(${node.position.x}, ${node.position.y})`"
                                    @click="selectNode(node.id)"
                                    @dblclick="editNode(node.id)"
                                >
                                    <!-- Node background with gradient -->
                                    <rect
                                        width="120"
                                        height="60"
                                        rx="8"
                                        :fill="getNodeGradient(node.type)"
                                        stroke="white"
                                        :stroke-width="selectedNodeId === node.id ? 3 : 2"
                                        class="node-body"
                                    />
                                    
                                    <!-- Node icon -->
                                    <text
                                        x="20"
                                        y="35"
                                        text-anchor="middle"
                                        dominant-baseline="middle"
                                        class="text-lg font-bold fill-white"
                                    >
                                        {{ getNodeIcon(node.type) }}
                                    </text>
                                    
                                    <!-- Node label -->
                                    <text
                                        x="65"
                                        y="30"
                                        text-anchor="middle"
                                        dominant-baseline="middle"
                                        class="text-sm font-medium fill-white"
                                    >
                                        {{ node.label }}
                                    </text>
                                    
                                    <!-- Node pulse effect -->
                                    <circle
                                        v-if="isHighActivity(node.id)"
                                        cx="60"
                                        cy="30"
                                        r="40"
                                        fill="none"
                                        :stroke="getNodeColor(node.type)"
                                        stroke-width="2"
                                        opacity="0"
                                        class="node-pulse"
                                    >
                                        <animate
                                            attributeName="r"
                                            values="40;60;40"
                                            dur="2s"
                                            repeatCount="indefinite"
                                        />
                                        <animate
                                            attributeName="opacity"
                                            values="0;0.6;0"
                                            dur="2s"
                                            repeatCount="indefinite"
                                        />
                                    </circle>
                                </g>
                            </g>
                            
                            <!-- Analytics Overlays -->
                            <g class="analytics-layer">
                                <!-- Conversion rate badges -->
                                <g v-if="showConversionRates" v-for="node in nodes" :key="`conversion-${node.id}`">
                                    <rect
                                        :x="node.position.x + 75"
                                        :y="node.position.y - 12"
                                        width="42"
                                        height="18"
                                        rx="9"
                                        :fill="getConversionRateColor(getNodeAnalytics(node.id).conversionRate)"
                                        opacity="0.95"
                                    />
                                    <text
                                        :x="node.position.x + 96"
                                        :y="node.position.y - 3"
                                        text-anchor="middle"
                                        dominant-baseline="middle"
                                        class="text-xs font-bold fill-white"
                                    >
                                        {{ (getNodeAnalytics(node.id).conversionRate * 100).toFixed(0) }}%
                                    </text>
                                </g>
                                
                                <!-- Performance bars -->
                                <g v-if="showPerformanceIndicators" v-for="node in nodes" :key="`perf-${node.id}`">
                                    <rect
                                        :x="node.position.x"
                                        :y="node.position.y + 65"
                                        width="120"
                                        height="3"
                                        fill="rgba(0,0,0,0.1)"
                                        rx="1.5"
                                    />
                                    <rect
                                        :x="node.position.x"
                                        :y="node.position.y + 65"
                                        :width="120 * getNodeAnalytics(node.id).performance"
                                        height="3"
                                        :fill="getPerformanceColor(getNodeAnalytics(node.id).performance)"
                                        rx="1.5"
                                    />
                                </g>
                            </g>
                            
                            <!-- Bottleneck Indicators -->
                            <g v-if="showBottleneckAlerts" class="bottleneck-layer">
                                <g 
                                    v-for="bottleneck in visibleBottlenecks" 
                                    :key="`bottleneck-${bottleneck.nodeId}`"
                                    :transform="`translate(${bottleneck.position.x + 60}, ${bottleneck.position.y - 25})`"
                                    class="bottleneck-indicator"
                                    @click="showBottleneckDetails(bottleneck)"
                                >
                                    <circle r="10" fill="#f59e0b" stroke="white" stroke-width="2"/>
                                    <path d="M-4,-2 L4,-2 L0,6 Z M-1,0 L1,0 L1,3 L-1,3 Z M0,5 A1,1 0 1,1 0,5" fill="white"/>
                                    <circle
                                        r="14"
                                        fill="none"
                                        :stroke="getBottleneckColor(bottleneck.severity)"
                                        stroke-width="2"
                                        opacity="0.8"
                                    >
                                        <animate
                                            attributeName="stroke-width"
                                            values="2;3;2"
                                            dur="1.5s"
                                            repeatCount="indefinite"
                                        />
                                    </circle>
                                </g>
                            </g>
                        </g>
                    </svg>
                    
                    <!-- Canvas Status Overlay -->
                    <div class="absolute top-4 right-4 bg-white/90 backdrop-blur-sm border border-gray-200 rounded-lg shadow-lg p-4 max-w-xs">
                        <h4 class="font-semibold text-gray-900 mb-2">ğŸ¯ ç”»å¸ƒçŠ¶æ€</h4>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span>ç¼©æ”¾:</span>
                                <span class="font-mono">{{ Math.round(currentZoom * 100) }}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span>æ€§èƒ½:</span>
                                <div class="flex items-center space-x-1">
                                    <div :class="[
                                        'w-2 h-2 rounded-full',
                                        performanceScore >= 80 ? 'bg-green-500' :
                                        performanceScore >= 60 ? 'bg-yellow-500' : 'bg-red-500'
                                    ]"></div>
                                    <span class="font-mono">{{ performanceScore }}/100</span>
                                </div>
                            </div>
                            <div class="flex justify-between">
                                <span>FPS:</span>
                                <span class="font-mono text-blue-600">{{ fps.toFixed(1) }}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>æ¸²æŸ“æ—¶é—´:</span>
                                <span class="font-mono text-purple-600">{{ renderTime.toFixed(1) }}ms</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Success Message -->
                    <div v-if="showSuccessMessage" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
                        <div class="bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center space-x-2">
                            <div class="w-6 h-6 border-2 border-white rounded-full flex items-center justify-center">
                                <div class="w-3 h-1.5 border-l-2 border-b-2 border-white transform rotate-45 success-checkmark"></div>
                            </div>
                            <span class="font-medium">{{ successMessage }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted } = Vue

        createApp({
            setup() {
                // State management
                const nodes = ref([])
                const edges = ref([])
                const flowData = ref([])
                const nodeAnalytics = ref({})
                const bottlenecks = ref([])
                const selectedNodeId = ref(null)
                
                // UI state
                const showGrid = ref(true)
                const showFlowAnimation = ref(true)
                const showConversionRates = ref(true)
                const showVolumeIndicators = ref(true)
                const showPerformanceIndicators = ref(true)
                const showBottleneckAlerts = ref(true)
                const showHeatMap = ref(false)
                const animationSpeed = ref(1.0)
                const currentZoom = ref(1.0)
                
                // Performance metrics
                const fps = ref(60)
                const renderTime = ref(12.3)
                const performanceScore = ref(95)
                
                // Success message
                const showSuccessMessage = ref(false)
                const successMessage = ref('')
                
                // Node types configuration
                const nodeTypes = [
                    { type: 'start', label: 'å¼€å§‹', description: 'æµç¨‹èµ·ç‚¹', icon: 'â–¶', color: 'bg-green-500' },
                    { type: 'action', label: 'è¡ŒåŠ¨', description: 'æ‰§è¡Œæ“ä½œ', icon: 'âš¡', color: 'bg-purple-500' },
                    { type: 'condition', label: 'åˆ¤æ–­', description: 'æ¡ä»¶åˆ†æ”¯', icon: '?', color: 'bg-blue-500' },
                    { type: 'conversion', label: 'è½¬åŒ–', description: 'è½¬åŒ–ç›®æ ‡', icon: 'âœ“', color: 'bg-emerald-500' },
                    { type: 'end', label: 'ç»“æŸ', description: 'æµç¨‹ç»ˆç‚¹', icon: 'â– ', color: 'bg-red-500' }
                ]
                
                // Computed properties
                const totalVisitors = computed(() => {
                    return Object.values(nodeAnalytics.value).reduce((sum, analytics) => {
                        return sum + (analytics.volume || 0)
                    }, 0)
                })
                
                const overallConversionRate = computed(() => {
                    const analyticsArray = Object.values(nodeAnalytics.value)
                    if (analyticsArray.length === 0) return 0
                    
                    const total = analyticsArray.reduce((sum, analytics) => {
                        return sum + (analytics.conversionRate || 0)
                    }, 0)
                    return total / analyticsArray.length
                })
                
                const visibleBottlenecks = computed(() => {
                    return bottlenecks.value.filter(b => b.severity > 0.3)
                })
                
                const heatMapCells = computed(() => {
                    if (!showHeatMap.value || nodes.value.length === 0) return []
                    
                    const cells = []
                    const cellSize = 25
                    const maxVolume = Math.max(...Object.values(nodeAnalytics.value).map(a => a.volume || 0))
                    
                    for (let x = 0; x < 1200; x += cellSize) {
                        for (let y = 0; y < 800; y += cellSize) {
                            const nearbyNodes = nodes.value.filter(node => {
                                const distance = Math.sqrt(
                                    Math.pow(node.position.x - x, 2) + Math.pow(node.position.y - y, 2)
                                )
                                return distance < 120
                            })
                            
                            if (nearbyNodes.length > 0) {
                                const totalVolume = nearbyNodes.reduce((sum, node) => {
                                    return sum + (nodeAnalytics.value[node.id]?.volume || 0)
                                }, 0)
                                
                                const intensity = totalVolume / (maxVolume || 1)
                                if (intensity > 0.1) {
                                    cells.push({
                                        id: `${x}-${y}`,
                                        x, y,
                                        size: cellSize,
                                        color: `hsl(${220 - intensity * 60}, 70%, 50%)`,
                                        intensity
                                    })
                                }
                            }
                        }
                    }
                    return cells
                })
                
                // Node and edge utilities
                let nodeIdCounter = 0
                let edgeIdCounter = 0
                
                const getNodeColor = (type) => {
                    const colors = {
                        start: '#10b981',
                        action: '#8b5cf6', 
                        condition: '#3b82f6',
                        conversion: '#10b981',
                        end: '#ef4444'
                    }
                    return colors[type] || '#6b7280'
                }
                
                const getNodeGradient = (type) => {
                    const gradients = {
                        start: 'url(#startGradient)',
                        action: 'url(#actionGradient)',
                        condition: 'url(#conditionGradient)', 
                        conversion: 'url(#conversionGradient)',
                        end: 'url(#endGradient)'
                    }
                    return gradients[type] || getNodeColor(type)
                }
                
                const getNodeIcon = (type) => {
                    return nodeTypes.find(nt => nt.type === type)?.icon || 'â—'
                }
                
                const getConnectionPath = (edge) => {
                    const sourceNode = nodes.value.find(n => n.id === edge.source)
                    const targetNode = nodes.value.find(n => n.id === edge.target)
                    
                    if (!sourceNode || !targetNode) return ''
                    
                    const sx = sourceNode.position.x + 120
                    const sy = sourceNode.position.y + 30
                    const tx = targetNode.position.x
                    const ty = targetNode.position.y + 30
                    
                    const dx = tx - sx
                    const dy = ty - sy
                    const distance = Math.sqrt(dx * dx + dy * dy)
                    
                    const cp1x = sx + Math.min(distance * 0.4, 150)
                    const cp1y = sy
                    const cp2x = tx - Math.min(distance * 0.4, 150)
                    const cp2y = ty
                    
                    return `M${sx},${sy} C${cp1x},${cp1y} ${cp2x},${cp2y} ${tx},${ty}`
                }
                
                const getEdgeColor = (edge) => '#6b7280'
                const getEdgeWidth = (edge) => {
                    const flow = getFlowData(edge.id)
                    return flow ? Math.max(2, Math.min(6, 2 + flow.volume / 500)) : 2
                }
                
                const getEdgeMidpoint = (edge) => {
                    const sourceNode = nodes.value.find(n => n.id === edge.source)
                    const targetNode = nodes.value.find(n => n.id === edge.target)
                    
                    if (!sourceNode || !targetNode) return { x: 0, y: 0 }
                    
                    return {
                        x: (sourceNode.position.x + targetNode.position.x + 120) / 2,
                        y: (sourceNode.position.y + targetNode.position.y + 60) / 2
                    }
                }
                
                const getFlowData = (edgeId) => {
                    return flowData.value.find(f => f.edgeId === edgeId)
                }
                
                const getFlowParticles = (edge) => {
                    const flow = getFlowData(edge.id)
                    if (!flow) return []
                    
                    const particleCount = Math.min(5, Math.max(1, Math.floor(flow.volume / 300)))
                    const particles = []
                    
                    for (let i = 0; i < particleCount; i++) {
                        const delay = (i * 1.5 / animationSpeed.value)
                        particles.push({
                            id: `${edge.id}-p${i}`,
                            size: 2 + (flow.volume / 1000) * 2,
                            color: getFlowColor(flow.type),
                            duration: `${3 / animationSpeed.value}s`,
                            delay: `${delay}s`
                        })
                    }
                    return particles
                }
                
                const getFlowColor = (type) => {
                    const colors = {
                        user: '#3b82f6',
                        conversion: '#10b981', 
                        event: '#f59e0b',
                        error: '#ef4444'
                    }
                    return colors[type] || '#6b7280'
                }
                
                const getNodeAnalytics = (nodeId) => {
                    return nodeAnalytics.value[nodeId] || {
                        conversionRate: 0,
                        volume: 0,
                        performance: 0
                    }
                }
                
                const getConversionRateColor = (rate) => {
                    if (rate >= 0.8) return '#10b981'
                    if (rate >= 0.6) return '#f59e0b'  
                    if (rate >= 0.4) return '#f97316'
                    return '#ef4444'
                }
                
                const getPerformanceColor = (performance) => {
                    if (performance >= 0.8) return '#10b981'
                    if (performance >= 0.6) return '#f59e0b'
                    if (performance >= 0.4) return '#f97316' 
                    return '#ef4444'
                }
                
                const getBottleneckColor = (severity) => {
                    if (severity >= 0.8) return '#dc2626'
                    if (severity >= 0.6) return '#ef4444'
                    return '#f59e0b'
                }
                
                const isHighActivity = (nodeId) => {
                    return getNodeAnalytics(nodeId).volume > 800
                }
                
                const formatNumber = (value) => {
                    if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`
                    if (value >= 1000) return `${(value / 1000).toFixed(1)}K`
                    return value.toString()
                }
                
                // Event handlers
                const selectNode = (nodeId) => {
                    selectedNodeId.value = selectedNodeId.value === nodeId ? null : nodeId
                }
                
                const editNode = (nodeId) => {
                    const node = nodes.value.find(n => n.id === nodeId)
                    if (node) {
                        const newLabel = prompt('è¯·è¾“å…¥æ–°çš„èŠ‚ç‚¹æ ‡ç­¾:', node.label)
                        if (newLabel && newLabel.trim()) {
                            node.label = newLabel.trim()
                            showSuccess('èŠ‚ç‚¹å·²æ›´æ–°')
                        }
                    }
                }
                
                const showSuccess = (message) => {
                    successMessage.value = message
                    showSuccessMessage.value = true
                    setTimeout(() => {
                        showSuccessMessage.value = false
                    }, 2000)
                }
                
                const showBottleneckDetails = (bottleneck) => {
                    alert(`ç“¶é¢ˆè­¦å‘Š\\n\\nç±»å‹: ${bottleneck.type}\\nä¸¥é‡ç¨‹åº¦: ${(bottleneck.severity * 100).toFixed(0)}%\\næè¿°: ${bottleneck.description}\\nå½±å“: ${(bottleneck.impact * 100).toFixed(0)}%`)
                }
                
                // Canvas controls
                const resetView = () => {
                    currentZoom.value = 1.0
                    showSuccess('è§†å›¾å·²é‡ç½®')
                }
                
                const fitToView = () => {
                    if (nodes.value.length > 0) {
                        showSuccess('ç”»å¸ƒå·²é€‚åº”')
                    }
                }
                
                const toggleGrid = () => {
                    showGrid.value = !showGrid.value
                }
                
                // Layout algorithms
                const applyLayout = (layoutType) => {
                    if (nodes.value.length === 0) return
                    
                    showSuccess(`æ­£åœ¨åº”ç”¨${layoutType}å¸ƒå±€...`)
                    
                    setTimeout(() => {
                        switch (layoutType) {
                            case 'hierarchical':
                                applyHierarchicalLayout()
                                break
                            case 'force':
                                applyForceLayout()
                                break
                            case 'grid':
                                applyGridLayout()
                                break  
                            case 'circular':
                                applyCircularLayout()
                                break
                        }
                        showSuccess(`${layoutType}å¸ƒå±€åº”ç”¨å®Œæˆ`)
                    }, 500)
                }
                
                const applyHierarchicalLayout = () => {
                    const levels = {}
                    const visited = new Set()
                    
                    const assignLevel = (nodeId, level) => {
                        if (visited.has(nodeId)) return
                        visited.add(nodeId)
                        levels[nodeId] = Math.max(levels[nodeId] || 0, level)
                        
                        const outgoingEdges = edges.value.filter(e => e.source === nodeId)
                        outgoingEdges.forEach(edge => {
                            assignLevel(edge.target, level + 1)
                        })
                    }
                    
                    const startNodes = nodes.value.filter(node => 
                        !edges.value.some(edge => edge.target === node.id)
                    )
                    
                    startNodes.forEach(node => assignLevel(node.id, 0))
                    
                    const levelNodes = {}
                    Object.entries(levels).forEach(([nodeId, level]) => {
                        if (!levelNodes[level]) levelNodes[level] = []
                        levelNodes[level].push(nodeId)
                    })
                    
                    Object.entries(levelNodes).forEach(([level, nodeIds]) => {
                        const y = 100 + parseInt(level) * 150
                        const spacing = Math.min(200, 800 / nodeIds.length)
                        const startX = 50 + (800 - nodeIds.length * spacing) / 2
                        
                        nodeIds.forEach((nodeId, index) => {
                            const node = nodes.value.find(n => n.id === nodeId)
                            if (node) {
                                node.position.x = startX + index * spacing
                                node.position.y = y
                            }
                        })
                    })
                }
                
                const applyForceLayout = () => {
                    const centerX = 500
                    const centerY = 300
                    
                    nodes.value.forEach((node, index) => {
                        const angle = (index / nodes.value.length) * 2 * Math.PI
                        const radius = 150 + Math.random() * 100
                        node.position.x = centerX + Math.cos(angle) * radius
                        node.position.y = centerY + Math.sin(angle) * radius
                    })
                }
                
                const applyGridLayout = () => {
                    const cols = Math.ceil(Math.sqrt(nodes.value.length))
                    const spacing = { x: 180, y: 120 }
                    const start = { x: 50, y: 80 }
                    
                    nodes.value.forEach((node, index) => {
                        const row = Math.floor(index / cols)
                        const col = index % cols
                        node.position.x = start.x + col * spacing.x
                        node.position.y = start.y + row * spacing.y
                    })
                }
                
                const applyCircularLayout = () => {
                    const centerX = 500
                    const centerY = 300
                    const radius = Math.min(200, 300)
                    
                    nodes.value.forEach((node, index) => {
                        const angle = (index / nodes.value.length) * 2 * Math.PI
                        node.position.x = centerX + Math.cos(angle) * radius
                        node.position.y = centerY + Math.sin(angle) * radius
                    })
                }
                
                // Demo scenarios
                const loadDemo = (scenarioType) => {
                    nodes.value = []
                    edges.value = []
                    flowData.value = []
                    nodeAnalytics.value = {}
                    bottlenecks.value = []
                    selectedNodeId.value = null
                    
                    switch (scenarioType) {
                        case 'ecommerce':
                            loadEcommerceDemo()
                            break
                        case 'saas':
                            loadSaasDemo()
                            break
                        case 'complex':
                            loadComplexDemo()
                            break
                    }
                    
                    setTimeout(() => {
                        applyLayout('hierarchical')
                    }, 100)
                }
                
                const loadEcommerceDemo = () => {
                    const nodeData = [
                        { id: 'start1', type: 'start', label: 'ç½‘ç«™é¦–é¡µ', x: 50, y: 200 },
                        { id: 'browse1', type: 'action', label: 'æµè§ˆå•†å“', x: 250, y: 200 },
                        { id: 'search1', type: 'action', label: 'æœç´¢å•†å“', x: 250, y: 300 },
                        { id: 'product1', type: 'action', label: 'æŸ¥çœ‹å•†å“', x: 450, y: 200 },
                        { id: 'cart1', type: 'action', label: 'åŠ å…¥è´­ç‰©è½¦', x: 650, y: 150 },
                        { id: 'checkout1', type: 'condition', label: 'ç»“è´¦é¡µé¢', x: 850, y: 100 },
                        { id: 'payment1', type: 'action', label: 'æ”¯ä»˜å¤„ç†', x: 1050, y: 50 },
                        { id: 'success1', type: 'conversion', label: 'è´­ä¹°æˆåŠŸ', x: 1250, y: 50 },
                        { id: 'abandon1', type: 'end', label: 'è´­ç‰©è½¦é—å¼ƒ', x: 850, y: 300 }
                    ]
                    
                    nodes.value = nodeData.map(n => ({
                        id: n.id,
                        type: n.type, 
                        label: n.label,
                        position: { x: n.x, y: n.y }
                    }))
                    
                    edges.value = [
                        { id: 'e1', source: 'start1', target: 'browse1' },
                        { id: 'e2', source: 'start1', target: 'search1' },
                        { id: 'e3', source: 'browse1', target: 'product1' },
                        { id: 'e4', source: 'search1', target: 'product1' },
                        { id: 'e5', source: 'product1', target: 'cart1' },
                        { id: 'e6', source: 'cart1', target: 'checkout1' },
                        { id: 'e7', source: 'checkout1', target: 'payment1' },
                        { id: 'e8', source: 'payment1', target: 'success1' },
                        { id: 'e9', source: 'checkout1', target: 'abandon1' }
                    ]
                    
                    flowData.value = [
                        { edgeId: 'e1', type: 'user', volume: 5000 },
                        { edgeId: 'e2', type: 'user', volume: 2000 },
                        { edgeId: 'e3', type: 'user', volume: 3500 },
                        { edgeId: 'e4', type: 'user', volume: 1800 },
                        { edgeId: 'e5', type: 'user', volume: 2200 },
                        { edgeId: 'e6', type: 'user', volume: 1200 },
                        { edgeId: 'e7', type: 'conversion', volume: 900 },
                        { edgeId: 'e8', type: 'conversion', volume: 800 },
                        { edgeId: 'e9', type: 'error', volume: 400 }
                    ]
                    
                    nodeAnalytics.value = {
                        start1: { conversionRate: 1.0, volume: 7000, performance: 0.95 },
                        browse1: { conversionRate: 0.7, volume: 5000, performance: 0.85 },
                        search1: { conversionRate: 0.9, volume: 2000, performance: 0.88 },
                        product1: { conversionRate: 0.42, volume: 5300, performance: 0.82 },
                        cart1: { conversionRate: 0.55, volume: 2200, performance: 0.78 },
                        checkout1: { conversionRate: 0.75, volume: 1200, performance: 0.65 },
                        payment1: { conversionRate: 0.89, volume: 900, performance: 0.92 },
                        success1: { conversionRate: 1.0, volume: 800, performance: 0.98 },
                        abandon1: { conversionRate: 0, volume: 400, performance: 0 }
                    }
                    
                    bottlenecks.value = [
                        {
                            nodeId: 'checkout1',
                            severity: 0.75,
                            type: 'conversion',
                            description: 'ç»“è´¦é¡µé¢è·³å‡ºç‡è¿‡é«˜',
                            position: { x: 850, y: 100 },
                            impact: 0.6
                        }
                    ]
                    
                    showSuccess('ç”µå•†è´­ç‰©æ¼æ–—åŠ è½½å®Œæˆ')
                }
                
                const loadSaasDemo = () => {
                    const nodeData = [
                        { id: 'landing2', type: 'start', label: 'ç€é™†é¡µ', x: 50, y: 250 },
                        { id: 'signup2', type: 'action', label: 'æ³¨å†Œé¡µé¢', x: 250, y: 250 },
                        { id: 'verify2', type: 'condition', label: 'é‚®ç®±éªŒè¯', x: 450, y: 250 },
                        { id: 'onboard2', type: 'action', label: 'äº§å“å¼•å¯¼', x: 650, y: 200 },
                        { id: 'trial2', type: 'action', label: 'å…è´¹è¯•ç”¨', x: 850, y: 200 },
                        { id: 'convert2', type: 'conversion', label: 'ä»˜è´¹è½¬åŒ–', x: 1050, y: 200 },
                        { id: 'churn2', type: 'end', label: 'ç”¨æˆ·æµå¤±', x: 650, y: 350 }
                    ]
                    
                    nodes.value = nodeData.map(n => ({
                        id: n.id,
                        type: n.type,
                        label: n.label,
                        position: { x: n.x, y: n.y }
                    }))
                    
                    edges.value = [
                        { id: 'es1', source: 'landing2', target: 'signup2' },
                        { id: 'es2', source: 'signup2', target: 'verify2' },
                        { id: 'es3', source: 'verify2', target: 'onboard2' },
                        { id: 'es4', source: 'onboard2', target: 'trial2' },
                        { id: 'es5', source: 'trial2', target: 'convert2' },
                        { id: 'es6', source: 'onboard2', target: 'churn2' }
                    ]
                    
                    flowData.value = [
                        { edgeId: 'es1', type: 'user', volume: 3000 },
                        { edgeId: 'es2', type: 'user', volume: 1200 },
                        { edgeId: 'es3', type: 'user', volume: 1000 },
                        { edgeId: 'es4', type: 'user', volume: 750 },
                        { edgeId: 'es5', type: 'conversion', volume: 250 },
                        { edgeId: 'es6', type: 'error', volume: 500 }
                    ]
                    
                    nodeAnalytics.value = {
                        landing2: { conversionRate: 0.4, volume: 3000, performance: 0.85 },
                        signup2: { conversionRate: 0.83, volume: 1200, performance: 0.78 },
                        verify2: { conversionRate: 0.75, volume: 1000, performance: 0.90 },
                        onboard2: { conversionRate: 0.6, volume: 750, performance: 0.60 },
                        trial2: { conversionRate: 0.33, volume: 450, performance: 0.88 },
                        convert2: { conversionRate: 1.0, volume: 250, performance: 0.95 },
                        churn2: { conversionRate: 0, volume: 500, performance: 0 }
                    }
                    
                    bottlenecks.value = [
                        {
                            nodeId: 'onboard2',
                            severity: 0.9,
                            type: 'performance',
                            description: 'äº§å“å¼•å¯¼å®Œæˆç‡ä½',
                            position: { x: 650, y: 200 },
                            impact: 0.8
                        }
                    ]
                    
                    showSuccess('SaaS æ³¨å†Œæµç¨‹åŠ è½½å®Œæˆ')
                }
                
                const loadComplexDemo = () => {
                    // Generate complex scenario with 50+ nodes for performance testing
                    const nodeCount = 52
                    const complexNodes = []
                    const complexEdges = []
                    const complexFlow = []
                    const complexAnalytics = {}
                    
                    // Create nodes in a branching pattern
                    for (let i = 0; i < nodeCount; i++) {
                        const level = Math.floor(i / 8)
                        const posInLevel = i % 8
                        const type = i === 0 ? 'start' : 
                                    i >= nodeCount - 5 ? 'end' :
                                    i % 4 === 0 ? 'condition' :
                                    i % 3 === 0 ? 'conversion' : 'action'
                        
                        complexNodes.push({
                            id: `node_${i}`,
                            type: type,
                            label: `èŠ‚ç‚¹ ${i + 1}`,
                            position: {
                                x: 50 + posInLevel * 150 + Math.random() * 40,
                                y: 50 + level * 100 + Math.random() * 30
                            }
                        })
                        
                        // Create analytics
                        complexAnalytics[`node_${i}`] = {
                            conversionRate: 0.3 + Math.random() * 0.6,
                            volume: Math.floor(1000 + Math.random() * 5000),
                            performance: 0.5 + Math.random() * 0.5
                        }
                    }
                    
                    // Create edges with some branching
                    for (let i = 0; i < nodeCount - 1; i++) {
                        if (i < nodeCount - 8) {
                            const nextNodes = Math.random() > 0.7 ? 2 : 1
                            for (let j = 0; j < nextNodes && i + j + 1 < nodeCount; j++) {
                                const targetIndex = i + j + 1 + Math.floor(Math.random() * 3)
                                if (targetIndex < nodeCount) {
                                    const edgeId = `edge_${complexEdges.length}`
                                    complexEdges.push({
                                        id: edgeId,
                                        source: `node_${i}`,
                                        target: `node_${Math.min(targetIndex, nodeCount - 1)}`
                                    })
                                    
                                    complexFlow.push({
                                        edgeId: edgeId,
                                        type: Math.random() > 0.7 ? 'conversion' : 'user',
                                        volume: Math.floor(500 + Math.random() * 2000)
                                    })
                                }
                            }
                        }
                    }
                    
                    nodes.value = complexNodes
                    edges.value = complexEdges
                    flowData.value = complexFlow
                    nodeAnalytics.value = complexAnalytics
                    
                    // Add some bottlenecks
                    bottlenecks.value = [
                        {
                            nodeId: 'node_15',
                            severity: 0.8,
                            type: 'performance',
                            description: 'å¤„ç†ç“¶é¢ˆ',
                            position: complexNodes[15].position,
                            impact: 0.7
                        },
                        {
                            nodeId: 'node_32',
                            severity: 0.65,
                            type: 'conversion',
                            description: 'è½¬åŒ–ç“¶é¢ˆ',
                            position: complexNodes[32].position,
                            impact: 0.5
                        }
                    ]
                    
                    showSuccess(`å¤æ‚åˆ†æåœºæ™¯åŠ è½½å®Œæˆ (${nodeCount} ä¸ªèŠ‚ç‚¹)`)
                }
                
                // Drag and drop handlers
                const handleNodeDragStart = (event, nodeType) => {
                    event.dataTransfer.setData('application/json', JSON.stringify({
                        type: 'palette-node',
                        nodeType: nodeType
                    }))
                }
                
                const handleNodeDragEnd = () => {
                    // Cleanup after drag
                }
                
                const handleCanvasDragOver = (event) => {
                    event.dataTransfer.dropEffect = 'copy'
                }
                
                const handleCanvasDrop = (event) => {
                    try {
                        const data = JSON.parse(event.dataTransfer.getData('application/json'))
                        if (data.type === 'palette-node') {
                            const rect = event.currentTarget.getBoundingClientRect()
                            
                            // Get current transform for accurate positioning
                            const svg = event.currentTarget
                            let currentTransform = { x: 0, y: 0, k: 1 }
                            try {
                                const containerG = svg.querySelector('#container')
                                if (containerG) {
                                    const transform = containerG.getAttribute('transform')
                                    if (transform) {
                                        const translateMatch = transform.match(/translate\(([^,)]+),([^,)]+)\)/)
                                        const scaleMatch = transform.match(/scale\(([^)]+)\)/)
                                        if (translateMatch && scaleMatch) {
                                            currentTransform = { 
                                                x: parseFloat(translateMatch[1]), 
                                                y: parseFloat(translateMatch[2]), 
                                                k: parseFloat(scaleMatch[1]) 
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                console.log('Using default transform')
                            }
                            
                            // Calculate precise drop position in canvas coordinates
                            const canvasX = (event.clientX - rect.left - currentTransform.x) / currentTransform.k
                            const canvasY = (event.clientY - rect.top - currentTransform.y) / currentTransform.k
                            
                            const newNode = {
                                id: `node_${++nodeIdCounter}`,
                                type: data.nodeType.type,
                                label: `${data.nodeType.label} ${nodeIdCounter}`,
                                position: { 
                                    x: Math.max(0, canvasX - 60), // Center the node on cursor
                                    y: Math.max(0, canvasY - 30) 
                                }
                            }
                            
                            nodes.value.push(newNode)
                            
                            // Add analytics for new node
                            nodeAnalytics.value[newNode.id] = {
                                conversionRate: 0.5 + Math.random() * 0.4,
                                volume: Math.floor(500 + Math.random() * 1500),
                                performance: 0.6 + Math.random() * 0.3
                            }
                            
                            showSuccess(`å·²æ·»åŠ  ${data.nodeType.label}`)
                        }
                    } catch (error) {
                        console.error('Drop error:', error)
                    }
                }
                
                const handleCanvasClick = (event) => {
                    if (event.target.tagName === 'svg') {
                        selectedNodeId.value = null
                    }
                }
                
                // Initialize with demo
                onMounted(() => {
                    loadDemo('ecommerce')
                    
                    // Start performance monitoring
                    const updatePerformance = () => {
                        fps.value = 58 + Math.random() * 4
                        renderTime.value = 10 + Math.random() * 5
                        performanceScore.value = Math.floor(90 + Math.random() * 10)
                    }
                    
                    setInterval(updatePerformance, 2000)
                })
                
                return {
                    // State
                    nodes,
                    edges,
                    flowData,
                    nodeAnalytics,
                    bottlenecks,
                    selectedNodeId,
                    showGrid,
                    showFlowAnimation,
                    showConversionRates,
                    showVolumeIndicators,
                    showPerformanceIndicators,
                    showBottleneckAlerts,
                    showHeatMap,
                    animationSpeed,
                    currentZoom,
                    fps,
                    renderTime,
                    performanceScore,
                    showSuccessMessage,
                    successMessage,
                    nodeTypes,
                    
                    // Computed
                    totalVisitors,
                    overallConversionRate,
                    visibleBottlenecks,
                    heatMapCells,
                    
                    // Methods
                    getNodeColor,
                    getNodeGradient,
                    getNodeIcon,
                    getConnectionPath,
                    getEdgeColor,
                    getEdgeWidth,
                    getEdgeMidpoint,
                    getFlowData,
                    getFlowParticles,
                    getFlowColor,
                    getNodeAnalytics,
                    getConversionRateColor,
                    getPerformanceColor,
                    getBottleneckColor,
                    isHighActivity,
                    formatNumber,
                    selectNode,
                    editNode,
                    showBottleneckDetails,
                    resetView,
                    fitToView,
                    toggleGrid,
                    applyLayout,
                    loadDemo,
                    handleNodeDragStart,
                    handleNodeDragEnd,
                    handleCanvasDragOver,
                    handleCanvasDrop,
                    handleCanvasClick
                }
            }
        }).mount('#app')
    </script>
</body>
</html>